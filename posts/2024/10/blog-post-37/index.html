<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Sparsity Promoting Dynamic Mode Decomposition: A Game Changer in Data-Driven Analysis | Shubham Goswami, PhD </title> <meta name="author" content="Shubham Goswami, PhD"> <meta name="description" content="Personal and professional website of Shubham Goswami, PhD. "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://goswami-13.github.io/posts/2024/10/blog-post-37/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Sparsity Promoting Dynamic Mode Decomposition: A Game Changer in Data-Driven Analysis",
            "description": "",
            "published": "October 09, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Shubham</span> Goswami, PhD </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Guides </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Sparsity Promoting Dynamic Mode Decomposition: A Game Changer in Data-Driven Analysis</h1> <p></p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> </nav> </d-contents> <p>In the world of data-driven analysis, extracting meaningful patterns from complex fluid flows is a significant challenge. Sparsity Promoting Dynamic Mode Decomposition (SPDMD) offers a powerful approach to uncovering the most dominant features while discarding redundant information, leading to a more efficient and insightful decomposition. This method blends the mathematical elegance of Dynamic Mode Decomposition (DMD) with sparse optimization techniques, providing a robust framework to identify critical structures in high-dimensional data.</p> <figure> <img src="https://goswami-13.github.io/images/Post36/BlogLogo.jpeg" width="80%"> </figure> <p>Dynamic Mode Decomposition (DMD) has become a cornerstone of data-driven modeling in fluid dynamics, providing a powerful means to break down complex, high-dimensional flow data into fundamental spatiotemporal modes. However, standard DMD methods face several limitations, particularly in handling translational invariances and transient phenomena. Check out my previous article on DMD and its limitations <a href="https://medium.com/gitconnected/exploring-the-limitations-of-dynamic-mode-decomposition-dmd-157352371660" rel="external nofollow noopener" target="_blank">here</a>. These limitations highlight the importance of extending DMD methodologies to more sophisticated versions, ones that tweak the DMD algorithm such that these limitations can be overcome. In this article, Lets explore one such variant of DMD names Sparsity-promoting Dynamic Mode Decomposition.</p> <p>Standard DMD often generate an excessive number of modes, many of which are redundant or heavily influenced by noise, making it challenging to pinpoint the essential flow dynamics. This lack of selectivity can obscure important features and complicate the interpretation of results, particularly in cases involving large datasets or systems with high noise levels. Sparsity Promoting Dynamic Mode Decomposition (SPDMD) was developed by <a href="https://doi.org/10.1063/1.4863670" rel="external nofollow noopener" target="_blank">Jovanovic et al. (2014)</a> to address these challenges. By integrating sparse optimization techniques, SPDMD selectively retains only the most significant modes, effectively filtering out the less relevant ones. This enhances the clarity and interpretability of the decomposition, leading to a more concise representation of the underlying physics. The sparsity constraint also reduces computational costs, making SPDMD particularly suitable for real-time applications and large-scale simulations.</p> <p>This approach has shown great promise in various applications, such as identifying coherent structures in turbulent flows, detecting wake vortices in aerodynamics, and uncovering dominant patterns in environmental monitoring datasets. For instance, in studying wake flows behind<a href="https://doi.org/10.1017/jfm.2021.271" rel="external nofollow noopener" target="_blank"> bluff bodies</a>, SPDMD has been able to isolate the most critical vortical structures responsible for energy transfer, offering deeper insights into the wake dynamics than traditional DMD methods. Similarly, in climate science, SPDMD has helped identify key modes of variability in ocean currents and atmospheric patterns, improving the understanding of large-scale environmental phenomena.</p> <p>In this blog, lets understand the fundamentals of SPDMD using a toy example and python to revolutionize data-driven analysis in fluid dynamics and beyond. Lets begin!!</p> <h1 id="sparsity-promoting-dmd">Sparsity-Promoting DMD</h1> <p>The key idea behind Sparsity-Promoting Dynamic Mode Decomposition (SPDMD) is straightforward: How can we find the most representative DMD modes to capture the essential dynamics of a system? While this question may seem simple, it is more profound than one might initially think. Traditionally, Dynamic Mode Decomposition (DMD) is performed by a human expert who carefully selects the DMD modes based on their experience and understanding of the data. But what happens when we want to automate this process, removing the need for human intervention?</p> <p>This is where SPDMD comes into play. Similar to how methods like the Optimal Singular Value Hard Threshold (OSVHT) provide an automated approach for Singular Value Decomposition (SVD), SPDMD offers a way to automate the selection of DMD modes. SPDMD leverages an optimization algorithm to redefine the calculation of mode amplitudes in DMD, aiming to reconstruct the original dataset using the fewest possible modes. The goal is to extract the most critical dynamics of the system. The term “sparsity-promoting” refers to the preference for solutions with a minimal number of nonzero modes, focusing on the most impactful dynamic features.</p> <p>Building upon the classical DMD framework, SPDMD introduces a sparsity constraint that selectively identifies the most important dynamic modes. The process begins similarly to traditional DMD: given a sequence of snapshots (time-series data) from a fluid flow or another dynamical system, DMD seeks a low-rank approximation of the data by decomposing it into spatial modes, each characterized by its temporal evolution through an eigenvalue.</p> <p>The innovation of SPDMD lies in its use of a sparsity-promoting optimization technique, typically incorporating an $L_1$-norm regularization term. Unlike the $L_2$-norm used in traditional methods, the $L_1$-norm encourages sparsity by penalizing the number of non-zero entries. In the context of DMD, this approach allows the optimization algorithm to identify a minimal subset of modes that best represent the system’s dynamics, minimizing the influence of less significant or redundant modes.</p> <p>For a comprehensive overview of the mathematics behind Dynamic Mode Decomposition (DMD), please refer to my <a href="https://medium.com/gitconnected/decoding-dynamics-the-mathematical-heart-of-dynamic-mode-decomposition-dmd-169e9a2eec07" rel="external nofollow noopener" target="_blank">previous article</a>.</p> <p>Recall that the DMD mode amplitudes are given by:</p> \[b = \Phi^\dagger x_1\] <p>Where, $\Phi$ represent the DMD modes, defined as:</p> \[\Phi = UW\] <p>The optimization problem for SPDMD can be mathematically formulated as:</p> \[\min_{b} ||X - \Phi diag(b)V^\ast||_F^2 + \lambda ||b||_1\] <p>where:</p> <ul> <li>$X$ is the matrix containing the snapshot data,</li> <li>$\Phi$ is the matrix of DMD modes,</li> <li>$b$ is a vector of mode amplitudes,</li> <li>$\lambda$ is a sparsity parameter controlling the balance between reconstruction accuracy and sparsity.</li> </ul> <p>By adjusting the parameter $\lambda$, SPDMD determines how many modes are retained, enabling a more compact representation of the data. As $\lambda$ increases, the method promotes greater sparsity, resulting in fewer selected modes. This yields a clearer and more interpretable set of modes that capture the most dominant and physically meaningful features of the system.</p> <p>To solve this optimization problem, SPDMD employs the Alternating Direction Method of Multipliers (ADMM) algorithm. ADMM is particularly effective for problems with large datasets, constraints, or regularization terms that promote sparsity. It iteratively searches for the optimal mode amplitude vector $b$ that minimizes the cost function while ensuring the vector is sparse, containing very few non-zero entries.</p> <h1 id="toy-example">Toy Example</h1> <p>To illustrate the concept of SPDMD, let’s explore a toy example. We will begin by loading the necessary modules into a Jupyter notebook:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.colors</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">scipy</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">from</span> <span class="n">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">io</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span> <span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="sh">'</span><span class="s">font.family</span><span class="sh">'</span> <span class="p">:</span> <span class="sh">'</span><span class="s">Times New Roman</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">text.usetex</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>

<span class="n">savePath</span> <span class="o">=</span> <span class="sh">'</span><span class="s">E:/Blog_Posts/OpenFOAM/ROM_Series/Post36/</span><span class="sh">'</span>
</code></pre></div></div> <p>Next, let’s generate a toy signal consisting of three distinct modes and some added noise. The resulting data will be mean-removed and normalized to better illustrate the dynamics captured by SPDMD.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">Xm</span><span class="p">,</span> <span class="n">Tm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="n">M1</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">cosh</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Xm</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Xm</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="mf">1.5j</span><span class="o">*</span><span class="n">Tm</span><span class="p">)</span> <span class="c1"># primary mode
</span><span class="n">M2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">Xm</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="mf">2.0j</span><span class="o">*</span><span class="n">Tm</span><span class="p">)</span> <span class="c1"># secondary mode
</span><span class="n">M3</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="mf">3.2</span><span class="o">*</span><span class="n">Xm</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cosh</span><span class="p">(</span><span class="mf">3.2j</span><span class="o">*</span><span class="n">Tm</span><span class="p">)</span> <span class="c1"># tertiary mode
</span><span class="n">M4</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">Xm</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tm</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># noise
</span>
<span class="n">data_matrix</span> <span class="o">=</span> <span class="n">M1</span> <span class="o">+</span> <span class="n">M2</span> <span class="o">+</span> <span class="n">M3</span> <span class="o">+</span> <span class="n">M4</span>
</code></pre></div></div> <p>You can visualize the three modes and the noise as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Ub</span> <span class="o">=</span> <span class="mf">0.015</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="nf">contourf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">M1</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="mi">501</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="sh">'</span><span class="s">RdBu</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$x$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$t$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Mode 1</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="nf">contourf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">M2</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="mi">501</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="sh">'</span><span class="s">RdBu</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$x$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$t$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Mode 2</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="nf">contourf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">M3</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="mi">501</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="sh">'</span><span class="s">RdBu</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$x$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$t$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Mode 3</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="nf">contourf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">M4</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="mi">501</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="sh">'</span><span class="s">RdBu</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$x$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$t$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Noise</span><span class="sh">'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/Post36/AllSignals.jpeg" width="80%"> </figure> <p>The combination of these three modes, along with the added noise, forms the data matrix that we will input into the DMD algorithm. This data matrix appears as follows:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/DataMatrix.jpeg" width="80%"> </figure> <p>The algorithm for standard Dynamic Mode Decomposition (DMD) is as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">DMD</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1">### Truncate the SVD matrices
</span>    <span class="n">Ur</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="p">:</span><span class="n">r</span><span class="p">]</span>
    <span class="n">Sr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">diag</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
    <span class="n">Vr</span> <span class="o">=</span> <span class="n">Vh</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">r</span><span class="p">]</span>
    
    <span class="c1">### Build the Atilde and find the eigenvalues and eigenvectors
</span>    <span class="n">Atilde</span> <span class="o">=</span> <span class="n">Ur</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span> <span class="o">@</span> <span class="n">X2</span> <span class="o">@</span> <span class="n">Vr</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">inv</span><span class="p">(</span><span class="n">Sr</span><span class="p">)</span>
    <span class="n">Lambda</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">eig</span><span class="p">(</span><span class="n">Atilde</span><span class="p">)</span>
    
    <span class="c1">### Compute the DMD modes
</span>    <span class="n">Phi</span> <span class="o">=</span> <span class="n">X2</span> <span class="o">@</span> <span class="n">Vr</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">inv</span><span class="p">(</span><span class="n">Sr</span><span class="p">)</span> <span class="o">@</span> <span class="n">W</span>
    
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">Lambda</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span> <span class="c1">### continuous time eigenvalues
</span>    
    <span class="c1">### Compute the amplitudes
</span>    
    <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">lstsq</span><span class="p">(</span><span class="n">Phi</span><span class="p">,</span> <span class="n">X1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rcond</span><span class="o">=</span><span class="bp">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">### DMD mode amplitudes
</span>    
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">lstsq</span><span class="p">(</span><span class="n">Phi</span><span class="p">,</span> <span class="n">X2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rcond</span><span class="o">=</span><span class="bp">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">### DMD mode amplitudes
</span>    
    <span class="k">return</span> <span class="n">Phi</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">alpha1</span><span class="p">,</span> <span class="n">b</span>
</code></pre></div></div> <p>Now, let’s pass the data matrix into the above DMD algorithm:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Time shifted snapshot matrix
</span><span class="n">X1</span> <span class="o">=</span> <span class="n">data_matrix</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">X2</span> <span class="o">=</span> <span class="n">data_matrix</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

<span class="n">r</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1"># Rank of truncation
</span><span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># DMD
</span><span class="n">Phi</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">alpha1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">DMD</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</code></pre></div></div> <p>The next step in the DMD workflow is to reconstruct a matrix representing the time evolution of the system. To do this, we compute the time dynamics and obtain the DMD reconstruction:</p> \[X_{DMD} = \Phi \cdot \Psi\] <p>Typically, the system’s initial conditions at $x_0$ are used to create a time evolution matrix. However, we will use an alternative formulation that leverages a Vandermonde matrix:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/Vandermond_DMD.png" width="10%"> </figure> <p>Where, $V_\mu$ is the Vandermonde matrix and $\dagger$ is the Moore-Penrose pseudo-inverse of a matrix.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># compute time evolution (concise way)
</span><span class="n">Vand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vander</span><span class="p">(</span><span class="n">Lambda</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">Psi</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vand</span><span class="p">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">b</span><span class="p">).</span><span class="n">T</span> <span class="c1"># equivalently, Psi = dot(diag(b), Vand)
</span></code></pre></div></div> <p>We can then reconstruct the reduced-order approximation of the data as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">D_dmd</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">Phi</span><span class="p">,</span> <span class="n">Psi</span><span class="p">)</span> <span class="c1"># reconstruct data
</span></code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/Post36/Comparison1.jpeg" width="80%"> </figure> <h1 id="the-catch">The Catch</h1> <p>Now, here’s the catch: we are not restricted to using the initial conditions ($x_0$) of the system to construct the amplitude vector b, traditionally defined as:</p> <p>$b = \Phi^\dagger x_0$</p> <p>Instead, we can potentially choose b to be a vector that produces a time evolution even closer to the original data by minimizing the reconstruction error. This allows us to redefine the DMD mode amplitudes by minimizing the following objective:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/SPDMD_2.png" width="10%"> </figure> <p>To simplify the first term, we can use the matrix trace properties, as detailed in <a href="https://doi.org/10.1063/1.4863670" rel="external nofollow noopener" target="_blank">Jovanovic et al. (2014)</a>:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/SPDMD_3.png" width="10%"> </figure> <p>where:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/SPDMD_4.png" width="10%"> </figure> <p>To promote sparsity in the vector b, we introduce an $L_1$ penalty. The purpose of this penalty is to encourage a sparse b vector, containing very few non-zero entries. This optimization is performed using the Alternating Direction Method of Multipliers (ADMM) algorithm. The ADMM code provided below is a direct translation of the MATLAB code used by <a href="https://doi.org/10.1063/1.4863670" rel="external nofollow noopener" target="_blank">Jovanovic et al. (2014)</a>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">multiply</span><span class="p">,</span> <span class="n">diag</span>
<span class="kn">from</span> <span class="n">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">pinv</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">cholesky</span>
<span class="kn">from</span> <span class="n">scipy.linalg</span> <span class="kn">import</span> <span class="n">svd</span><span class="p">,</span> <span class="n">svdvals</span>
<span class="kn">from</span> <span class="n">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span> <span class="k">as</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="n">scipy.sparse</span> <span class="kn">import</span> <span class="n">vstack</span> <span class="k">as</span> <span class="n">spvstack</span>
<span class="kn">from</span> <span class="n">scipy.sparse</span> <span class="kn">import</span> <span class="n">hstack</span> <span class="k">as</span> <span class="n">sphstack</span>
<span class="kn">from</span> <span class="n">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>

<span class="k">def</span> <span class="nf">admm_for_dmd</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gamma_vec</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">eps_abs</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">eps_rel</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>

    <span class="c1"># blank return value
</span>    <span class="n">answer</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="sh">'</span><span class="s">ADMMAnswer</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})()</span>
    
    <span class="c1"># check input vars
</span>    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="n">q</span><span class="p">)[:,</span><span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">gamma_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">P</span><span class="p">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">invalid P</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span><span class="p">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">invalid q</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gamma_vec</span><span class="p">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">invalid gamma_vec</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="c1"># number of optimization variables
</span>    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    
    <span class="c1"># identity matrix
</span>    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># allocate memory for gamma-dependent output variables
</span>    <span class="n">answer</span><span class="p">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma_vec</span>
    <span class="n">answer</span><span class="p">.</span><span class="n">Nz</span>    <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="nf">len</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">),])</span> <span class="c1"># number of non-zero amplitudes
</span>    <span class="n">answer</span><span class="p">.</span><span class="n">Jsp</span>   <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="nf">len</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">),])</span> <span class="c1"># square of Frobenius norm (before polishing)
</span>    <span class="n">answer</span><span class="p">.</span><span class="n">Jpol</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="nf">len</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">),])</span> <span class="c1"># square of Frobenius norm (after polishing)
</span>    <span class="n">answer</span><span class="p">.</span><span class="n">Ploss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="nf">len</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">),])</span> <span class="c1"># optimal performance loss (after polishing)
</span>    <span class="n">answer</span><span class="p">.</span><span class="n">xsp</span>   <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># vector of amplitudes (before polishing)
</span>    <span class="n">answer</span><span class="p">.</span><span class="n">xpol</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># vector of amplitudes (after polishing)
</span>    
    <span class="c1"># Cholesky factorization of matrix P + (rho/2)*I
</span>    <span class="n">Prho</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="p">(</span><span class="n">rho</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">I</span>
    <span class="n">Plow</span> <span class="o">=</span> <span class="nf">cholesky</span><span class="p">(</span><span class="n">Prho</span><span class="p">)</span>
    <span class="n">Plow_star</span> <span class="o">=</span> <span class="n">Plow</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span>

    <span class="c1"># sparse P (for KKT system)
</span>    <span class="n">Psparse</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">gamma</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">gamma_vec</span><span class="p">):</span>

        <span class="c1"># initial conditions
</span>        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Lagrange multiplier
</span>        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># copy of x
</span>
        <span class="c1"># Use ADMM to solve the gamma-parameterized problem  
</span>        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>

            <span class="c1"># x-minimization step
</span>            <span class="n">u</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
            <span class="c1"># x = solve((P + (rho/2) * I), (q + rho * u))
</span>            <span class="n">xnew</span> <span class="o">=</span> <span class="nf">solve</span><span class="p">(</span><span class="n">Plow_star</span><span class="p">,</span> <span class="nf">solve</span><span class="p">(</span><span class="n">Plow</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="p">(</span><span class="n">rho</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">))</span>

            <span class="c1"># z-minimization step       
</span>            <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">xnew</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
            <span class="c1"># soft-thresholding of v
</span>            <span class="n">znew</span> <span class="o">=</span> <span class="nf">multiply</span><span class="p">(</span><span class="nf">multiply</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">divide</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">v</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">))</span>

            <span class="c1"># primal and dual residuals
</span>            <span class="n">res_prim</span> <span class="o">=</span> <span class="nf">norm</span><span class="p">(</span><span class="n">xnew</span> <span class="o">-</span> <span class="n">znew</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">res_dual</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="nf">norm</span><span class="p">(</span><span class="n">znew</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Lagrange multiplier update step
</span>            <span class="n">y</span> <span class="o">+=</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">xnew</span> <span class="o">-</span> <span class="n">znew</span><span class="p">)</span>

            <span class="c1"># stopping criteria
</span>            <span class="n">eps_prim</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">eps_abs</span> <span class="o">+</span> <span class="n">eps_rel</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">([</span><span class="nf">norm</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nf">norm</span><span class="p">(</span><span class="n">znew</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
            <span class="n">eps_dual</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">eps_abs</span> <span class="o">+</span> <span class="n">eps_rel</span> <span class="o">*</span> <span class="nf">norm</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="nf">if </span><span class="p">(</span><span class="n">res_prim</span> <span class="o">&lt;</span> <span class="n">eps_prim</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_dual</span> <span class="o">&lt;</span> <span class="n">eps_dual</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">znew</span>        

        <span class="c1"># record output data
</span>        <span class="n">answer</span><span class="p">.</span><span class="n">xsp</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">()</span> <span class="c1"># vector of amplitudes
</span>        <span class="n">answer</span><span class="p">.</span><span class="n">Nz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">count_nonzero</span><span class="p">(</span><span class="n">answer</span><span class="p">.</span><span class="n">xsp</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span> <span class="c1"># number of non-zero amplitudes
</span>        <span class="n">answer</span><span class="p">.</span><span class="n">Jsp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="c1"># Frobenius norm (before polishing)
</span>
        <span class="c1"># polishing of the nonzero amplitudes
</span>        <span class="c1"># form the constraint matrix E for E^T x = 0
</span>        <span class="n">ind_zero</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="c1"># find indices of zero elements of z
</span>        <span class="n">m</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">ind_zero</span><span class="p">)</span> <span class="c1"># number of zero elements
</span>                
        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># form KKT system for the optimality conditions
</span>            <span class="n">E</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:,</span><span class="n">ind_zero</span><span class="p">]</span>
            <span class="n">E</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">KKT</span> <span class="o">=</span> <span class="nf">spvstack</span><span class="p">([</span>
                <span class="nf">sphstack</span><span class="p">([</span><span class="n">Psparse</span><span class="p">,</span> <span class="n">E</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="sh">'</span><span class="s">csc</span><span class="sh">'</span><span class="p">),</span>
                <span class="nf">sphstack</span><span class="p">([</span><span class="n">E</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">,</span> <span class="nf">sparse</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)],</span> <span class="nb">format</span><span class="o">=</span><span class="sh">'</span><span class="s">csc</span><span class="sh">'</span><span class="p">),</span>
                <span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="sh">'</span><span class="s">csc</span><span class="sh">'</span><span class="p">)</span>            
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vstack</span><span class="p">([</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="sh">'</span><span class="s">complex</span><span class="sh">'</span><span class="p">)])</span> <span class="c1"># stack vertically
</span>
            <span class="c1"># solve KKT system
</span>            <span class="n">sol</span> <span class="o">=</span> <span class="nf">spsolve</span><span class="p">(</span><span class="n">KKT</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="nf">solve</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

        <span class="c1"># vector of polished (optimal) amplitudes
</span>        <span class="n">xpol</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

        <span class="c1"># record output data
</span>        <span class="n">answer</span><span class="p">.</span><span class="n">xpol</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xpol</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">()</span>

        <span class="c1"># polished (optimal) least-squares residual
</span>        <span class="n">answer</span><span class="p">.</span><span class="n">Jpol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">xpol</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">),</span> <span class="n">xpol</span><span class="p">))</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">,</span> <span class="n">xpol</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">s</span><span class="p">)</span>

        <span class="c1"># polished (optimal) performance loss 
</span>        <span class="n">answer</span><span class="p">.</span><span class="n">Ploss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">answer</span><span class="p">.</span><span class="n">Jpol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">s</span><span class="p">)</span>

        <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div> <p>To apply this optimization, let’s first perform Singular Value Decomposition (SVD) and compute the necessary matrices P, q and s matrix:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">data_matrix</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="n">Vand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vander</span><span class="p">(</span><span class="n">Lambda</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="nf">multiply</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">Phi</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">,</span> <span class="n">Phi</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">conj</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">Vand</span><span class="p">,</span> <span class="n">Vand</span><span class="p">.</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">)))</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">conj</span><span class="p">(</span><span class="nf">diag</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">Vand</span><span class="p">,</span> <span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="nf">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">Vh</span><span class="p">)).</span><span class="nf">conj</span><span class="p">().</span><span class="n">T</span><span class="p">),</span> <span class="n">Phi</span><span class="p">)))</span>
<span class="n">s</span> <span class="o">=</span> <span class="nf">norm</span><span class="p">(</span><span class="nf">diag</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">ord</span><span class="o">=</span><span class="sh">'</span><span class="s">fro</span><span class="sh">'</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</code></pre></div></div> <p>Next, we’ll define a range of 𝛾 values to examine their influence on the optimal b vectors:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gamma_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">logspace</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">log10</span><span class="p">(</span><span class="mf">0.05</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">log10</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span> <span class="mi">150</span><span class="p">)</span>
</code></pre></div></div> <p>We can then solve the optimization problem using the following code:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bNew</span> <span class="o">=</span> <span class="nf">admm_for_dmd</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gamma_vec</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">eps_abs</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">eps_rel</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
</code></pre></div></div> <p>The SPDMD algorithm is now complete. The main goal is to reconstruct the DMD reduced-order model with the fewest number of DMD modes, while still capturing the overall dynamics of the dataset. After completing the optimization, let’s explore the <code class="language-plaintext highlighter-rouge">bNew</code> object. You can get the available attributes and methods by using:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">dir</span><span class="p">(</span><span class="n">bNew</span><span class="p">)</span>

<span class="c1">### OUTPUT
# ['Jpol', 'Jsp', 'Nz', 'Ploss', 'gamma', 'xpol', 'xsp']
</span></code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">Nz</code> represents the number of non-zero modes in the solution, while <code class="language-plaintext highlighter-rouge">PLoss</code> indicates the performance loss — a normalized metric reflecting the overall model error resulting from using the optimal b. The attribute <code class="language-plaintext highlighter-rouge">xpol</code> contains the values of the optimal b corresponding to specific gamma values.</p> <p>For instance, when $\gamma = 0.073$, we obtain 30 non-zero elements in the optimal b vector. Using this optimal b for reconstructing the DMD reduced model, we get the following result:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/gamma_1.jpeg" width="80%"> </figure> <p>Similarly, we can reconstruct the system dynamics using only the 9, 3, and 2 most important DMD modes, as shown below:</p> <figure> <img src="https://goswami-13.github.io/images/Post36/gamma_2.jpeg" width="80%"> </figure> <figure> <img src="https://goswami-13.github.io/images/Post36/gamma_3.jpeg" width="80%"> </figure> <figure> <img src="https://goswami-13.github.io/images/Post36/gamma_4.jpeg" width="80%"> </figure> <p>At higher resolutions, the first three modes are more distinguishable due to varying noise levels. Finally, SPDMD allows for a reconstruction using just a single mode — the most dominant mode that effectively captures the overall dynamics of the system. The power of SPDMD lies in its ability to selectively retain the most dominant modes while promoting sparsity. This approach ensures that the reconstructed model remains compact yet representative of the essential dynamics of the system.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/posts/2025/06/blog-post-54/">Tabulating 6-DOF Motion Kinematics in OpenFOAM using Python</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/posts/2025/06/blog-post-53/">Setting Up Overset Mesh Cases in OpenFOAM Made Easy</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/posts/2025/06/blog-post-52/">An Introduction to Overset Mesh in OpenFOAM</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/posts/2025/05/blog-post-51/">Python Tools for Analyzing and Visualizing Mesh Motion Simulations</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/posts/2025/03/blog-post-50/">Simulating Pure Pitching and Heaving Motions in OpenFOAM</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Shubham Goswami, PhD. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script defer src="/assets/js/diff2html-setup.js?80a6e52ce727518bbd3aed2bb6ba5601" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script defer src="/assets/js/leaflet-setup.js?b6313931e203b924523e2d8b75fe8874" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script defer src="/assets/js/chartjs-setup.js?183c5859923724fb1cb3c67593848e71" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script defer src="/assets/js/echarts-setup.js?738178999630746a8d0cfc261fc47c2c" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script defer src="/assets/js/vega-setup.js?7c7bee055efe9312afc861b128fe5f36" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/assets/js/typograms.js?062e75bede72543443762dc3fe36c7a5"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>