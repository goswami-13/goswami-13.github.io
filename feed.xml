<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://goswami-13.github.io/goswami-13/feed.xml" rel="self" type="application/atom+xml"/><link href="https://goswami-13.github.io/goswami-13/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-11T03:44:55+00:00</updated><id>https://goswami-13.github.io/goswami-13/feed.xml</id><title type="html">blank</title><subtitle>Personal and professional website of Shubham Goswami, PhD. </subtitle><entry><title type="html">Tabulating 6-DOF Motion Kinematics in OpenFOAM using Python</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-54/" rel="alternate" type="text/html" title="Tabulating 6-DOF Motion Kinematics in OpenFOAM using Python"/><published>2025-06-01T00:00:00+00:00</published><updated>2025-06-01T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-54</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-54/"><![CDATA[<p>The overset mesh approach in OpenFOAM is a powerful tool for simulating complex motion scenarios. Among its many features, the <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> kinematics definition offers precise control over six degrees of freedom, enabling seamless integration of pre-defined motion data into simulations. This blog explores the fundamentals and implementation of this method, leveraging Python for tabulating the motion kinematics. By leveraging <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code>, engineers and researchers can unlock advance mesh motion capabalities using overset mesh approach and OpenFOAM.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog12/BlogLogo.gif" width="80%"/> </figure> <p>Simulating complex motion in CFD often requires precise control over how objects move within the computational domain. While standard prescribed motion definitions in OpenFOAM, such as <code class="language-plaintext highlighter-rouge">oscillatingDisplacement</code> or <code class="language-plaintext highlighter-rouge">angularOscillatingDisplacement</code>, can handle simple heaving or pitching motions, they fall short when dealing with intricate, multi-degree-of-freedom scenarios. One of such scenatios is mixed-motion such as heaving and pitching cylinder. These methods lack the flexibility to accommodate dynamically evolving motion that depends on pre-tabulated or real-world data.</p> <p>The <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> kinematics definition addresses these limitations by allowing users to prescribe motion across all six degrees of freedom, three translational and three rotational, using time-series data. This approach is particularly valuable for cases where motion is complex, irregular, or influenced by external factors. In this blog, we explore how <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> integrates seamlessly with the overset mesh framework in OpenFOAM, enabling accurate and efficient simulation of dynamic systems. Additionally, we explore how Python can be used to prepare the required motion input files. For demonstration, I will again use the example of an oscillating square cylinder with a prescribed frequency. Download the case from my GitHub repository <a href="https://github.com/goswami-13/Overset_Base">here</a>.</p> <p>In this article, I will build upon my previous post on setting up overset mesh cases in OpenFOAM. For more detailed information, feel free to refer to that article.</p> <p>Lets begin!!!</p> <h1 id="understanding-tabulated6dofmotion">Understanding tabulated6DoFMotion</h1> <p>The <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> kinematics definition in OpenFOAM is a powerful tool for simulating complex, multi-dimensional motion. Unlike simpler prescribed motion methods, which are typically limited to angular or heaving patterns, this approach allows users to define motion across six degrees of freedom: three translational (x, y, z) and three rotational (roll, pitch, yaw).</p> <p>What sets this method apart is its ability to handle pre-tabulated motion data, where both the position and orientation of the object are specified as a function of time. This makes it particularly useful for scenarios involving irregular motion or where the motion is predefined through experimental measurements, analytical models, or external simulations. The motion data is typically stored in a plain text file or table, with each row representing a time step, accompanied by the corresponding values for translational and rotational displacements. During the simulation, OpenFOAM interpolates this data to ensure smooth and accurate movement of the mesh or object. By integrating the <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> definition with the overset mesh framework, users can effectively simulate dynamic systems, such as vehicles, marine vessels, or machinery components—without sacrificing computational efficiency or accuracy.</p> <p>The format for tabulated motion data in OpenFOAM is as follows: Each time step is specified with the reference time, followed by two groups of values: one for linear displacement and the other for angular displacement.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="c1">//number of data points in the file </span>
<span class="c1">//Position formatting is not important. File is based on the character sequence only. </span>
<span class="c1">//Vectors are not relative. Each vector is total displacement and total rotation.</span>
<span class="p">(</span>
<span class="c1">//(time_point ( (linear displacement vector) (rotation vector roll-yaw-pitch) ) )</span>
<span class="c1">//(seconds ( (following unit system, usually meters) (degrees) ) )</span>
<span class="p">(</span><span class="mi">0</span> <span class="p">(</span> <span class="p">(</span><span class="mf">0.25</span> <span class="mf">0.50</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">(</span><span class="mf">0.220</span> <span class="mf">0.30</span> <span class="mf">0.40</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="mf">0.25</span> <span class="p">(</span> <span class="p">(</span><span class="mf">0.50</span> <span class="mf">1.0</span> <span class="mf">2.0</span><span class="p">)</span> <span class="p">(</span><span class="mf">0.60</span> <span class="mf">0.60</span> <span class="mf">0.60</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="mf">0.75</span> <span class="p">(</span> <span class="p">(</span><span class="mf">0.75</span> <span class="mf">5.0</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">(</span><span class="mf">1.2</span> <span class="mf">2.4</span> <span class="mf">5.0</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="mf">10.0</span> <span class="p">(</span> <span class="p">(</span><span class="mf">0.1</span> <span class="mf">6.0</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">(</span><span class="mf">5.0</span> <span class="mf">3.0</span> <span class="mf">5.5</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div> <p>This file is typically stored as a <code class="language-plaintext highlighter-rouge">.dat</code> file within the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/constant/</code> directory. Once the motion is defined using this method, the tabulated data is read into the <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code> file by specifying the <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> motion function, as shown below:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2412                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/</span>
<span class="n">FoamFile</span>
<span class="p">{</span>
	  <span class="n">version</span>     <span class="mf">2.0</span><span class="p">;</span>
    <span class="n">format</span>      <span class="n">ascii</span><span class="p">;</span>
    <span class="k">class</span>       <span class="nc">dictionary</span><span class="p">;</span>
    <span class="n">object</span>      <span class="n">dynamicMeshDict</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

<span class="n">dynamicFvMesh</span>       <span class="n">dynamicOversetFvMesh</span><span class="p">;</span>

<span class="n">dynamicOversetFvMeshCoeffs</span>
<span class="p">{</span>
<span class="c1">//    layerRelax 0.3;</span>
<span class="p">}</span>

<span class="n">solver</span>          <span class="n">multiSolidBodyMotionSolver</span><span class="p">;</span>

<span class="n">multiSolidBodyMotionSolverCoeffs</span>
<span class="p">{</span>
    <span class="n">movingZone</span>
    <span class="p">{</span>	
		    <span class="n">solidBodyMotionFunction</span> <span class="n">tabulated6DoFMotion</span><span class="p">;</span>
        <span class="n">CofG</span>       <span class="p">(</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="p">);</span>
		    <span class="n">timeDataFileName</span>	<span class="s">"$FOAM_CASE/constant/pitchplunge.dat"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ************************************************************************* //</span>
</code></pre></div></div> <p>Now, let’s create a similar motion file using Python!</p> <h1 id="calculating-motion-kinematics-using-python">Calculating Motion Kinematics using Python</h1> <p>Generating a <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> file can be streamlined using Python, particularly when motion data is derived from mathematical models, experimental results, or external simulations. Python’s flexibility allows for the automation of the motion table creation, ensuring both accuracy and consistency. Additionally, Python’s versatility enables integration with real-world datasets, expanding the scope of this method even further.</p> <p>To begin, we’ll import the necessary Python modules in a Jupyter notebook:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.colors</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">fluidfoam</span> <span class="k">as</span> <span class="n">fl</span>
<span class="kn">import</span> <span class="n">scipy</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">matplotlib.animation</span> <span class="k">as</span> <span class="n">animation</span>
<span class="kn">import</span> <span class="n">pyvista</span> <span class="k">as</span> <span class="n">pv</span>
<span class="kn">import</span> <span class="n">imageio</span>
<span class="kn">import</span> <span class="n">io</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span> <span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="sh">'</span><span class="s">font.family</span><span class="sh">'</span> <span class="p">:</span> <span class="sh">'</span><span class="s">Times New Roman</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">text.usetex</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</code></pre></div></div> <p>Next, we define the motion parameters. The type of motion we are prescribing needs to be known. In this example, we will use the case of a heaving square cylinder. For translational motion, we define the following:</p> \[x(t) = z(t) = 0, y(t) = A sin(2\pi f t)\] <p>For the rotational motion, we define Roll ($\phi$ ϕ), Pitch ($\theta$ θ), and Yaw ($\psi$ ψ) as:</p> \[\phi(t) = \psi(t) = 0, \theta(t) = \theta_0 sin(2\pi f t + \Phi)\] <p>In this case, $\Phi$ Φ is the phase angle.</p> <p>We choose an amplitude (A) of 0.05 and a heaving frequency (f) of 1. The simulation will run for 2 periods of motion. <strong>This method requires the definition of a time step.</strong> Here, we choose a time step ($\Delta t$) of 0.004, and set $\Phi$ Φ and $\theta_0$ θ0 to 0.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span>
<span class="n">Period</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">f</span>
<span class="n">TotalNumberOfPeriods</span> <span class="o">=</span> <span class="mf">2.1</span>
<span class="n">TotalTime</span> <span class="o">=</span> <span class="n">TotalNumberOfPeriods</span><span class="o">*</span><span class="n">Period</span>
<span class="n">deltaT</span> <span class="o">=</span> <span class="mf">0.004</span>
<span class="n">Theta0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Phi</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">resolution</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">TotalTime</span><span class="o">/</span><span class="n">deltaT</span><span class="p">)</span> <span class="c1">#this is our time resolution, the number of data points our file will have
</span></code></pre></div></div> <p>Now, let’s define the time vector:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TotalTime</span><span class="p">,</span> <span class="n">deltaT</span><span class="p">)</span>
</code></pre></div></div> <p>Next, we define the linear and rotational displacement vectors:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#linear displacement
</span><span class="n">linearDisplacement</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">Time</span><span class="sh">'</span><span class="p">])</span>
<span class="n">linearDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">X</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">linearDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">Y</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span>
<span class="n">linearDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">Z</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">#rotational displacement
</span><span class="n">rotationalDisplacement</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">Time</span><span class="sh">'</span><span class="p">])</span>
<span class="n">rotationalDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">phi</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">rotationalDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">psi</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">rotationalDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">theta</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">((</span><span class="n">omega</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Phi</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">))</span>
</code></pre></div></div> <p>Finally, we save the motion file, adding the appropriate brackets and formatting as required by OpenFOAM:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">F:/Moving_Meshes_OFTest/OverSet_HeavePitch/Motion.dat</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="se">\n</span><span class="s">(</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">):</span>
        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">'</span><span class="s">(</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="s">((</span><span class="sh">'</span> <span class="o">+</span> 
                <span class="nf">str</span><span class="p">(</span><span class="n">linearDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">X</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> 
                <span class="nf">str</span><span class="p">(</span><span class="n">linearDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">Y</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> 
                <span class="nf">str</span><span class="p">(</span><span class="n">linearDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">Z</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="s">)(</span><span class="sh">'</span> <span class="o">+</span> 
                <span class="nf">str</span><span class="p">(</span><span class="n">rotationalDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">phi</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> 
                <span class="nf">str</span><span class="p">(</span><span class="n">rotationalDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">psi</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> 
                <span class="nf">str</span><span class="p">(</span><span class="n">rotationalDisplacement</span><span class="p">[</span><span class="sh">'</span><span class="s">theta</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="sh">'</span><span class="s">)))</span><span class="sh">'</span> <span class="o">+</span> 
                <span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p><strong>Important Note:</strong> Defining the motion in this way makes the <code class="language-plaintext highlighter-rouge">endTime</code> parameter in your <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/system/controlDict</code> obsolete. As such, the <code class="language-plaintext highlighter-rouge">endTime</code> in this case will be the final time specified in the <code class="language-plaintext highlighter-rouge">Motion.dat</code> file.</p> <h1 id="running-the-simulation">Running the Simulation</h1> <p>Running the simulation is simple. Follow the steps for running an overset simulation as described in my previous article:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Generate Meshes</span>
<span class="nb">cd </span>background/
fluent3DMeshToFoam Background.msh
<span class="nb">cd</span> ../overset/
fluent3DMeshToFoam Square.msh
<span class="nb">cd</span> ../background/

<span class="c"># merge meshes</span>
mergeMeshes <span class="nb">.</span> ../overset/ <span class="nt">-overwrite</span>

<span class="c"># Toposet and setFields</span>
topoSet
setFields
topoSet <span class="nt">-dict</span> system/topoSetDict_movingZone

<span class="c"># Run Simulation</span>
overPimpleDyMFoam
</code></pre></div></div> <p>The motion we defined should look as shown below:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog12/OS_Anim.gif" width="80%"/> </figure> <p>You can modify the heaving and pitching motion by adjusting the initial angle and phase angle accordingly.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog12/HeavePitch.gif" width="80%"/> </figure> <p>The combination of overset mesh and <code class="language-plaintext highlighter-rouge">tabulated6DoFMotion</code> in OpenFOAM offers an advanced framework for simulating dynamic systems with complex motion. By enabling six degrees of freedom and accommodating pre-tabulated motion data, this approach overcomes the limitations of standard prescribed motion definitions, providing unparalleled flexibility and accuracy. From setting up overset regions to defining motion data with Python, this blog has walked through the key steps for implementing such cases.</p>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[The overset mesh approach in OpenFOAM is a powerful tool for simulating complex motion scenarios. Among its many features, the tabulated6DoFMotion kinematics definition offers precise control over six degrees of freedom, enabling seamless integration of pre-defined motion data into simulations. This blog explores the fundamentals and implementation of this method, leveraging Python for tabulating the motion kinematics. By leveraging tabulated6DoFMotion, engineers and researchers can unlock advance mesh motion capabalities using overset mesh approach and OpenFOAM. Simulating complex motion in CFD often requires precise control over how objects move within the computational domain. While standard prescribed motion definitions in OpenFOAM, such as oscillatingDisplacement or angularOscillatingDisplacement, can handle simple heaving or pitching motions, they fall short when dealing with intricate, multi-degree-of-freedom scenarios. One of such scenatios is mixed-motion such as heaving and pitching cylinder. These methods lack the flexibility to accommodate dynamically evolving motion that depends on pre-tabulated or real-world data. The tabulated6DoFMotion kinematics definition addresses these limitations by allowing users to prescribe motion across all six degrees of freedom, three translational and three rotational, using time-series data. This approach is particularly valuable for cases where motion is complex, irregular, or influenced by external factors. In this blog, we explore how tabulated6DoFMotion integrates seamlessly with the overset mesh framework in OpenFOAM, enabling accurate and efficient simulation of dynamic systems. Additionally, we explore how Python can be used to prepare the required motion input files. For demonstration, I will again use the example of an oscillating square cylinder with a prescribed frequency. Download the case from my GitHub repository here. In this article, I will build upon my previous post on setting up overset mesh cases in OpenFOAM. For more detailed information, feel free to refer to that article. Lets begin!!! Understanding tabulated6DoFMotion The tabulated6DoFMotion kinematics definition in OpenFOAM is a powerful tool for simulating complex, multi-dimensional motion. Unlike simpler prescribed motion methods, which are typically limited to angular or heaving patterns, this approach allows users to define motion across six degrees of freedom: three translational (x, y, z) and three rotational (roll, pitch, yaw). What sets this method apart is its ability to handle pre-tabulated motion data, where both the position and orientation of the object are specified as a function of time. This makes it particularly useful for scenarios involving irregular motion or where the motion is predefined through experimental measurements, analytical models, or external simulations. The motion data is typically stored in a plain text file or table, with each row representing a time step, accompanied by the corresponding values for translational and rotational displacements. During the simulation, OpenFOAM interpolates this data to ensure smooth and accurate movement of the mesh or object. By integrating the tabulated6DoFMotion definition with the overset mesh framework, users can effectively simulate dynamic systems, such as vehicles, marine vessels, or machinery components—without sacrificing computational efficiency or accuracy. The format for tabulated motion data in OpenFOAM is as follows: Each time step is specified with the reference time, followed by two groups of values: one for linear displacement and the other for angular displacement. 4 //number of data points in the file //Position formatting is not important. File is based on the character sequence only. //Vectors are not relative. Each vector is total displacement and total rotation. ( //(time_point ( (linear displacement vector) (rotation vector roll-yaw-pitch) ) ) //(seconds ( (following unit system, usually meters) (degrees) ) ) (0 ( (0.25 0.50 1.0) (0.220 0.30 0.40) ) ) (0.25 ( (0.50 1.0 2.0) (0.60 0.60 0.60) ) ) (0.75 ( (0.75 5.0 1.0) (1.2 2.4 5.0) ) ) (10.0 ( (0.1 6.0 1.0) (5.0 3.0 5.5) ) ) ) This file is typically stored as a .dat file within the &lt;Case&gt;/constant/ directory. Once the motion is defined using this method, the tabulated data is read into the dynamicMeshDict file by specifying the tabulated6DoFMotion motion function, as shown below: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Website: www.openfoam.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 2.0; format ascii; class dictionary; object dynamicMeshDict; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dynamicFvMesh dynamicOversetFvMesh; dynamicOversetFvMeshCoeffs { // layerRelax 0.3; } solver multiSolidBodyMotionSolver; multiSolidBodyMotionSolverCoeffs { movingZone { solidBodyMotionFunction tabulated6DoFMotion; CofG ( 0 0 0 ); timeDataFileName "$FOAM_CASE/constant/pitchplunge.dat"; } } // ************************************************************************* // Now, let’s create a similar motion file using Python! Calculating Motion Kinematics using Python Generating a tabulated6DoFMotion file can be streamlined using Python, particularly when motion data is derived from mathematical models, experimental results, or external simulations. Python’s flexibility allows for the automation of the motion table creation, ensuring both accuracy and consistency. Additionally, Python’s versatility enables integration with real-world datasets, expanding the scope of this method even further. To begin, we’ll import the necessary Python modules in a Jupyter notebook: import matplotlib.colors import matplotlib.pyplot as plt import numpy as np import pandas as pd import fluidfoam as fl import scipy as sp import os import matplotlib.animation as animation import pyvista as pv import imageio import io %matplotlib inline plt.rcParams.update({'font.size' : 18, 'font.family' : 'Times New Roman', "text.usetex": True}) Next, we define the motion parameters. The type of motion we are prescribing needs to be known. In this example, we will use the case of a heaving square cylinder. For translational motion, we define the following: \[x(t) = z(t) = 0, y(t) = A sin(2\pi f t)\] For the rotational motion, we define Roll ($\phi$ ϕ), Pitch ($\theta$ θ), and Yaw ($\psi$ ψ) as: \[\phi(t) = \psi(t) = 0, \theta(t) = \theta_0 sin(2\pi f t + \Phi)\] In this case, $\Phi$ Φ is the phase angle. We choose an amplitude (A) of 0.05 and a heaving frequency (f) of 1. The simulation will run for 2 periods of motion. This method requires the definition of a time step. Here, we choose a time step ($\Delta t$) of 0.004, and set $\Phi$ Φ and $\theta_0$ θ0 to 0. A=0.05 f=1 omega=2*np.pi*f Period=1/f TotalNumberOfPeriods=2.1 TotalTime=TotalNumberOfPeriods*Period deltaT=0.004 Theta0=0 Phi=0 resolution=int(TotalTime/deltaT) #this is our time resolution, the number of data points our file will have Now, let’s define the time vector: time=np.arange(0, TotalTime, deltaT) Next, we define the linear and rotational displacement vectors: #linear displacement linearDisplacement=pd.DataFrame(data=time, columns=['Time']) linearDisplacement['X'] = 0 linearDisplacement['Y'] = A*np.sin(omega * time) linearDisplacement['Z'] = 0 #rotational displacement rotationalDisplacement=pd.DataFrame(data=time, columns=['Time']) rotationalDisplacement['phi'] = 0 rotationalDisplacement['psi'] = 0 rotationalDisplacement['theta'] = np.sin((omega * time) + (Phi*np.pi/180)) Finally, we save the motion file, adding the appropriate brackets and formatting as required by OpenFOAM: with open('F:/Moving_Meshes_OFTest/OverSet_HeavePitch/Motion.dat', 'w') as f: f.write(str(resolution) + '\n(\n') for i in range(resolution): f.write('(' + str(time[i]) + '((' + str(linearDisplacement['X'][i]) + ' ' + str(linearDisplacement['Y'][i]) + ' ' + str(linearDisplacement['Z'][i]) + ')(' + str(rotationalDisplacement['phi'][i]) + ' ' + str(rotationalDisplacement['psi'][i]) + ' ' + str(rotationalDisplacement['theta'][i]) + ')))' + '\n') f.write(')') Important Note: Defining the motion in this way makes the endTime parameter in your &lt;Case&gt;/system/controlDict obsolete. As such, the endTime in this case will be the final time specified in the Motion.dat file. Running the Simulation Running the simulation is simple. Follow the steps for running an overset simulation as described in my previous article: # Generate Meshes cd background/ fluent3DMeshToFoam Background.msh cd ../overset/ fluent3DMeshToFoam Square.msh cd ../background/ # merge meshes mergeMeshes . ../overset/ -overwrite # Toposet and setFields topoSet setFields topoSet -dict system/topoSetDict_movingZone # Run Simulation overPimpleDyMFoam The motion we defined should look as shown below: You can modify the heaving and pitching motion by adjusting the initial angle and phase angle accordingly. The combination of overset mesh and tabulated6DoFMotion in OpenFOAM offers an advanced framework for simulating dynamic systems with complex motion. By enabling six degrees of freedom and accommodating pre-tabulated motion data, this approach overcomes the limitations of standard prescribed motion definitions, providing unparalleled flexibility and accuracy. From setting up overset regions to defining motion data with Python, this blog has walked through the key steps for implementing such cases.]]></summary></entry><entry><title type="html">Python Tools for Analyzing and Visualizing Mesh Motion Simulations</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/05/blog-post-51/" rel="alternate" type="text/html" title="Python Tools for Analyzing and Visualizing Mesh Motion Simulations"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/05/blog-post-51</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/05/blog-post-51/"><![CDATA[<p>Postprocessing is a critical step in any simulation workflow, providing insights into the results and enabling effective communication of findings. When it comes to dynamic mesh motion simulations, visualizing the mesh deformation and understanding its effects on flow features can be particularly challenging. In this article, I’ll explore how to use Python for postprocessing such simulations, focusing on extracting, analyzing, and visualizing mesh motion data. With a combination of powerful libraries like Matplotlib, NumPy, and PyVista, we’ll unlock techniques to create meaningful visualizations and derive valuable insights from simulation results.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog9/BlogLogo.gif" width="80%"/> </figure> <p>Dynamic mesh motion simulations provide valuable insights into the interaction between moving boundaries and the surrounding flow. However, the true potential of these simulations is realized only through effective postprocessing, where mesh behavior is analyzed and visualized. In this blog, we’ll focus on extracting, visualizing, and analyzing mesh motion data using Python, showcasing practical techniques to interpret complex deformations and movements. Building on the foundational tutorials from my previous blogs on setting up mesh motion simulations, this article will guide you through postprocessing workflows, enabling you to transform raw data into actionable insights.</p> <p>II will build upon the tutorial cases introduced in my previous two articles. These include the simulation of flow around a heaving square cylinder (Available <a href="https://github.com/goswami-13/SquareCylinderRe100">here</a>) and flow around a thin flat plate aligned parallel to the flow direction (download <a href="https://github.com/goswami-13/ThinFlatPlate">here</a>).</p> <p>Lets Begin!!!</p> <h1 id="setting-up-the-environment">Setting Up the Environment</h1> <p>Before diving into postprocessing, ensure your environment is ready to handle the data efficiently. This involves installing essential Python libraries like:</p> <ul> <li><code class="language-plaintext highlighter-rouge">numpy</code> for numerical operations,</li> <li><code class="language-plaintext highlighter-rouge">matplotlib</code> for creating static and animated visualizations,</li> <li><code class="language-plaintext highlighter-rouge">pyvista</code> for handling and visualizing mesh data in 3D, and</li> <li><code class="language-plaintext highlighter-rouge">vtk</code> for working with VTK-formatted files.</li> </ul> <p>For setting up your Python environment, refer to my <a href="https://medium.com/gitconnected/building-your-python-toolbox-for-cfd-e9f2e86a02b1">previous article</a>.</p> <p>Here’s how you can set up the environment:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pip</span> <span class="n">install</span> <span class="n">numpy</span> <span class="n">matplotlib</span> <span class="n">pyvista</span> <span class="n">vtk</span>
</code></pre></div></div> <h1 id="understanding-motion-kinematics">Understanding motion kinematics</h1> <p>Beyond visualization, quantitative analysis can provide deeper insights into the dynamics of mesh motion. For instance, by visualizing the kinematics of mesh motion using Python, you can estimate the period of one pitching or heaving cycle and determine appropriate intervals for data writing. To get started, open a Jupyter notebook and import the necessary modules:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.colors</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">fluidfoam</span> <span class="k">as</span> <span class="n">fl</span>
<span class="kn">import</span> <span class="n">scipy</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">matplotlib.animation</span> <span class="k">as</span> <span class="n">animation</span>
<span class="kn">import</span> <span class="n">pyvista</span> <span class="k">as</span> <span class="n">pv</span>
<span class="kn">import</span> <span class="n">imageio</span>
<span class="kn">import</span> <span class="n">io</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span> <span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="sh">'</span><span class="s">font.family</span><span class="sh">'</span> <span class="p">:</span> <span class="sh">'</span><span class="s">Times New Roman</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">text.usetex</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="n">LinearSegmentedColormap</span><span class="p">.</span><span class="nf">from_list</span><span class="p">(</span><span class="sh">""</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">cyan</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">xkcd:azure</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">blue</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">xkcd:dark blue</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">white</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">xkcd:dark red</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">red</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">orange</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">])</span>
</code></pre></div></div> <p>The motion we aim to prescribe follows a sinusoidal wave, mathematically represented as:</p> \[y(t) = A sin(\omega t)\] <p>To define the motion, let’s specify the amplitude (A) and the frequency (f) of the sinusoidal wave:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Motion Xc = A Sin(2*pi*f*t)
</span><span class="n">A</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span>
<span class="n">Times</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.0004</span><span class="p">)</span>
<span class="n">Xc</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">Times</span><span class="p">)</span>
</code></pre></div></div> <p>Finally, we can plot the motion equation along with markers representing the time intervals at which data will be saved in OpenFOAM:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plot 
</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">Times</span><span class="p">,</span> <span class="n">Xc</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="sa">r</span><span class="sh">'</span><span class="s">$X_c = A \sin(2\pi f t)$</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">MarkEvery</span> <span class="o">=</span> <span class="mi">125</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">Times</span><span class="p">,</span> <span class="n">Xc</span><span class="p">,</span> <span class="sh">'</span><span class="s">ro</span><span class="sh">'</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Write Points</span><span class="sh">'</span><span class="p">,</span> <span class="n">markevery</span> <span class="o">=</span> <span class="n">MarkEvery</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">axhline</span><span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="sh">'</span><span class="s">--</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="sh">'</span><span class="s">best</span><span class="sh">'</span><span class="p">,</span> <span class="n">frameon</span> <span class="o">=</span> <span class="bp">False</span><span class="p">);</span> <span class="c1"># or 'best', 'upper right', etc
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.06</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$X_c$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$t$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <p>By visualizing this plot, you can observe the sinusoidal motion profile and identify the specific time intervals for data saving. This approach ensures that the data is captured consistently and aligns with the prescribed motion.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog9/Motion.jpeg" width="80%"/> </figure> <h1 id="extracting-mesh-data">Extracting Mesh Data</h1> <p>The first step in postprocessing is to extract mesh motion data from your simulation. OpenFOAM typically provides this information as displacement fields (<code class="language-plaintext highlighter-rouge">pointDisplacement</code>) or velocity fields (<code class="language-plaintext highlighter-rouge">motionUx</code>), which can be processed further. For 2D simulations, the <code class="language-plaintext highlighter-rouge">foamToVTK</code> utility simplifies this process by converting OpenFOAM case data into VTK format, making it easier to handle in Python. Once converted, you can use Python libraries like <code class="language-plaintext highlighter-rouge">pyvista</code> to load and manipulate the data.</p> <p>However, not all simulations are strictly 2D, and extracting meaningful slices or surfaces from 3D simulations is often necessary. OpenFOAM offers an efficient way to achieve this using the <code class="language-plaintext highlighter-rouge">surfaces</code> function object. This tool allows you to extract two-dimensional slices or surfaces from the dataset. To configure it, create a file named <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/system/surfaces</code> and set it up as shown below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>surfaces
<span class="o">{</span>
    <span class="nb">type            </span>surfaces<span class="p">;</span>
    libs            <span class="o">(</span><span class="s2">"libsampling.so"</span><span class="o">)</span><span class="p">;</span>
    writeControl   	timeStep<span class="p">;</span>
    writeInterval   10<span class="p">;</span>

    surfaceFormat   vtk<span class="p">;</span>
    fields          <span class="o">(</span>p U<span class="o">)</span><span class="p">;</span>

    interpolationScheme cellPoint<span class="p">;</span>

    surfaces
    <span class="o">{</span>
        zNormal
        <span class="o">{</span>
            <span class="nb">type        </span>cuttingPlane<span class="p">;</span>
            point       <span class="o">(</span>0 0 0.05<span class="o">)</span><span class="p">;</span>
            normal      <span class="o">(</span>0 0 1<span class="o">)</span><span class="p">;</span>
            interpolate <span class="nb">true</span><span class="p">;</span>
        <span class="o">}</span>
    <span class="o">}</span><span class="p">;</span>
<span class="o">}</span><span class="p">;</span>
</code></pre></div></div> <p>You can use this function object during runtime to extract surfaces at specified <code class="language-plaintext highlighter-rouge">writeIntervals</code>, or, as in this case, use it as a postprocessing tool after completing your simulation. For instance, if your simulation has reached statistical convergence, you can save surfaces for 50 time directories as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goswami@ME:/mnt/f/Moving_Meshes_OFTest/Org/Org<span class="nv">$ </span><span class="nb">ls
</span>0        4.56315  4.96315  5.36315  5.76315  6.16315  6.56315  6.96315  7.36315  7.76315  8.16315
4.24315  4.64315  5.04315  5.44315  5.84315  6.24315  6.64315  7.04315  7.44315  7.84315  constant
4.32315  4.72315  5.12315  5.52315  5.92315  6.32315  6.72315  7.12315  7.52315  7.92315  foam.foam
4.40315  4.80315  5.20315  5.60315  6.00315  6.40315  6.80315  7.20315  7.60315  8.00315  system
4.48315  4.88315  5.28315  5.68315  6.08315  6.48315  6.88315  7.28315  7.68315  8.08315
</code></pre></div></div> <p>Once your case is set up, open an OpenFOAM-sourced terminal and execute the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pimpleFoam <span class="nt">-postProcess</span> <span class="nt">-func</span> surfaces
</code></pre></div></div> <p>This command will process the simulation results and write the pressure and velocity data for the specified slice at each time directory. The output will be stored in the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/postProcessing/surfaces/</code> directory. A sample output might look like this:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goswami@ME:/mnt/f/Moving_Meshes_OFTest/Org/Org/postProcessing/surfaces<span class="nv">$ </span><span class="nb">ls
</span>4.24315  4.56315  4.88315  5.20315  5.52315  5.84315  6.16315  6.48315  6.80315  7.12315  7.44315  7.76315  8.08315
4.32315  4.64315  4.96315  5.28315  5.60315  5.92315  6.24315  6.56315  6.88315  7.20315  7.52315  7.84315  8.16315
4.40315  4.72315  5.04315  5.36315  5.68315  6.00315  6.32315  6.64315  6.96315  7.28315  7.60315  7.92315
4.48315  4.80315  5.12315  5.44315  5.76315  6.08315  6.40315  6.72315  7.04315  7.36315  7.68315  8.00315
</code></pre></div></div> <p>Each time directory will contain files for the extracted surfaces. For example:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goswami@ME:/mnt/f/Moving_Meshes_OFTest/Org/Org/postProcessing/surfaces<span class="nv">$ </span>tree 4.24315/
4.24315/
└── zNormal.vtp
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">zNormal.vtp</code> is the VTK file containing the pressure and velocity data for the slice at the specified time step.</p> <p>Now, let’s move to postprocessing in Python. Start by setting up the path variables and constants in your Jupyter notebook. These will help you organize and access the data efficiently in your analysis workflow.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Path Variables 
</span><span class="n">Path</span> <span class="o">=</span> <span class="sh">'</span><span class="s">F:/Moving_Meshes_OFTest/Org/Org/postProcessing/surfaces/</span><span class="sh">'</span>
<span class="n">save_path</span> <span class="o">=</span> <span class="sh">'</span><span class="s">F:/Moving_Meshes_OFTest/Org/</span><span class="sh">'</span>
<span class="n">save_Blog</span> <span class="o">=</span> <span class="sh">'</span><span class="s">F:/E_Drive/Blog_Posts/2025_Blogs/Blog9/</span><span class="sh">'</span>
<span class="n">Files</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>

<span class="c1"># Constants
</span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Ub</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div> <p>To begin, load the data from a single VTK file using the following code:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Data</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">Path</span> <span class="o">+</span> <span class="n">Files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">/zNormal.vtp</span><span class="sh">'</span><span class="p">)</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">Data</span><span class="p">.</span><span class="n">points</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">rows = </span><span class="sh">'</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="sh">'</span><span class="s">columns = </span><span class="sh">'</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
</code></pre></div></div> <p>To extract and compute the vorticity for all time steps, use <code class="language-plaintext highlighter-rouge">PyVista</code> within a loop. This approach enables the creation of a matrix containing the vorticity data:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Data</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">Path</span> <span class="o">+</span> <span class="n">Files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">/zNormal.vtp</span><span class="sh">'</span><span class="p">)</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">Data</span><span class="p">.</span><span class="n">points</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">rows = </span><span class="sh">'</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="sh">'</span><span class="s">columns = </span><span class="sh">'</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

<span class="c1">### For U
</span><span class="n">Snaps</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">Files</span><span class="p">)</span>
<span class="n">data_Vort</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span><span class="n">Snaps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">grid_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span><span class="n">Snaps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">grid_y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span><span class="n">Snaps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">grid_z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span><span class="n">Snaps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Snaps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">Path</span> <span class="o">+</span> <span class="n">Files</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">/zNormal.vtp</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">points</span>
    <span class="n">grid_x</span><span class="p">[:,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="sh">'</span><span class="s">F</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">grid_y</span><span class="p">[:,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="sh">'</span><span class="s">F</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">grid_z</span><span class="p">[:,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="sh">'</span><span class="s">F</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">gradData</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">compute_derivative</span><span class="p">(</span><span class="sh">'</span><span class="s">U</span><span class="sh">'</span><span class="p">,</span> <span class="n">vorticity</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">grad_pyvis</span> <span class="o">=</span> <span class="n">gradData</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">vorticity</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">data_Vort</span><span class="p">[:,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">grad_pyvis</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="sh">'</span><span class="s">F</span><span class="sh">'</span><span class="p">)</span>

<span class="n">np</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">VortZ.npy</span><span class="sh">'</span><span class="p">,</span> <span class="n">data_Vort</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">grid_x.npy</span><span class="sh">'</span><span class="p">,</span> <span class="n">grid_x</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">grid_y.npy</span><span class="sh">'</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">grid_z.npy</span><span class="sh">'</span><span class="p">,</span> <span class="n">grid_z</span><span class="p">)</span>
</code></pre></div></div> <p>After extracting the data, visualize the vorticity field with a contour plot:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Contour</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">/</span><span class="mf">0.1</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="nf">tricontourf</span><span class="p">(</span><span class="n">grid_x</span><span class="p">[:,</span><span class="n">Contour</span><span class="p">]</span><span class="o">/</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">[:,</span> <span class="n">Contour</span><span class="p">]</span><span class="o">/</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">data_Vort</span><span class="p">[:,</span><span class="n">Contour</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">),</span> 
                   <span class="n">levels</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">1.8</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1.8</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">)</span>
<span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">patches</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">plt</span><span class="p">.</span><span class="nc">Rectangle</span><span class="p">((</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">Omega</span><span class="o">*</span><span class="nf">float</span><span class="p">(</span><span class="n">Files</span><span class="p">[</span><span class="n">Contour</span><span class="p">])))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> 
                             <span class="n">ec</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">white</span><span class="sh">'</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">add_patch</span><span class="p">(</span><span class="n">patches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$x/d$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$y/d$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fig</span><span class="p">.</span><span class="nf">set_tight_layout</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">savefig</span><span class="p">(</span><span class="n">save_Blog</span> <span class="o">+</span> <span class="sh">'</span><span class="s">SqCylPlot.jpeg</span><span class="sh">'</span><span class="p">,</span> <span class="n">dpi</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span> <span class="n">bbox_inches</span> <span class="o">=</span> <span class="sh">'</span><span class="s">tight</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/2025/Blog9/SqCylPlot.jpeg" width="80%"/> </figure> <p>Since we are working with moving meshes, it’s crucial to account for the prescribed motion. For a sinusoidal motion, the position of the square cylinder at any time instant can be calculated using:</p> \[X_c = A sin(\omega T)\] <p>This enables precise positioning of the square cylinder patch in the plot. The same process can be followed for pure pitching and pure heaving simulations.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog9/PitchingGif.gif" width="80%"/> </figure> <figure> <img src="https://goswami-13.github.io/images/2025/Blog9/HeavingGif.gif" width="80%"/> </figure>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[Postprocessing is a critical step in any simulation workflow, providing insights into the results and enabling effective communication of findings. When it comes to dynamic mesh motion simulations, visualizing the mesh deformation and understanding its effects on flow features can be particularly challenging. In this article, I’ll explore how to use Python for postprocessing such simulations, focusing on extracting, analyzing, and visualizing mesh motion data. With a combination of powerful libraries like Matplotlib, NumPy, and PyVista, we’ll unlock techniques to create meaningful visualizations and derive valuable insights from simulation results. Dynamic mesh motion simulations provide valuable insights into the interaction between moving boundaries and the surrounding flow. However, the true potential of these simulations is realized only through effective postprocessing, where mesh behavior is analyzed and visualized. In this blog, we’ll focus on extracting, visualizing, and analyzing mesh motion data using Python, showcasing practical techniques to interpret complex deformations and movements. Building on the foundational tutorials from my previous blogs on setting up mesh motion simulations, this article will guide you through postprocessing workflows, enabling you to transform raw data into actionable insights. II will build upon the tutorial cases introduced in my previous two articles. These include the simulation of flow around a heaving square cylinder (Available here) and flow around a thin flat plate aligned parallel to the flow direction (download here). Lets Begin!!! Setting Up the Environment Before diving into postprocessing, ensure your environment is ready to handle the data efficiently. This involves installing essential Python libraries like: numpy for numerical operations, matplotlib for creating static and animated visualizations, pyvista for handling and visualizing mesh data in 3D, and vtk for working with VTK-formatted files. For setting up your Python environment, refer to my previous article. Here’s how you can set up the environment: pip install numpy matplotlib pyvista vtk Understanding motion kinematics Beyond visualization, quantitative analysis can provide deeper insights into the dynamics of mesh motion. For instance, by visualizing the kinematics of mesh motion using Python, you can estimate the period of one pitching or heaving cycle and determine appropriate intervals for data writing. To get started, open a Jupyter notebook and import the necessary modules: import matplotlib.colors import matplotlib.pyplot as plt import numpy as np import pandas as pd import fluidfoam as fl import scipy as sp import os import matplotlib.animation as animation import pyvista as pv import imageio import io %matplotlib inline plt.rcParams.update({'font.size' : 18, 'font.family' : 'Times New Roman', "text.usetex": True}) cmap=matplotlib.colors.LinearSegmentedColormap.from_list("", ["cyan", "xkcd:azure", "blue", "xkcd:dark blue", "white", "xkcd:dark red", "red", "orange", "yellow"]) The motion we aim to prescribe follows a sinusoidal wave, mathematically represented as: \[y(t) = A sin(\omega t)\] To define the motion, let’s specify the amplitude (A) and the frequency (f) of the sinusoidal wave: # Motion Xc=A Sin(2*pi*f*t) A=0.05 f=1 omega=2*np.pi*f Times=np.arange(0, 5, 0.0004) Xc=A*np.sin(omega*Times) Finally, we can plot the motion equation along with markers representing the time intervals at which data will be saved in OpenFOAM: # Plot fig, ax=plt.subplots(figsize = (11, 4)) ax.plot(Times, Xc, label=r'$X_c = A \sin(2\pi f t)$', color='blue', linewidth=1) MarkEvery=125 ax.plot(Times, Xc, 'ro', markersize=5, label='Write Points', markevery=MarkEvery) ax.axhline(y = 0, color='black', linestyle='--', linewidth=1) ax.legend(loc='best', frameon=False); # or 'best', 'upper right', etc ax.set_xlim([0, 5]) ax.set_ylim([-0.06, 0.1]) ax.set_ylabel(r'$X_c$') ax.set_xlabel(r'$t$') plt.show() By visualizing this plot, you can observe the sinusoidal motion profile and identify the specific time intervals for data saving. This approach ensures that the data is captured consistently and aligns with the prescribed motion. Extracting Mesh Data The first step in postprocessing is to extract mesh motion data from your simulation. OpenFOAM typically provides this information as displacement fields (pointDisplacement) or velocity fields (motionUx), which can be processed further. For 2D simulations, the foamToVTK utility simplifies this process by converting OpenFOAM case data into VTK format, making it easier to handle in Python. Once converted, you can use Python libraries like pyvista to load and manipulate the data. However, not all simulations are strictly 2D, and extracting meaningful slices or surfaces from 3D simulations is often necessary. OpenFOAM offers an efficient way to achieve this using the surfaces function object. This tool allows you to extract two-dimensional slices or surfaces from the dataset. To configure it, create a file named &lt;Case&gt;/system/surfaces and set it up as shown below: surfaces { type surfaces; libs ("libsampling.so"); writeControl timeStep; writeInterval 10; surfaceFormat vtk; fields (p U); interpolationScheme cellPoint; surfaces { zNormal { type cuttingPlane; point (0 0 0.05); normal (0 0 1); interpolate true; } }; }; You can use this function object during runtime to extract surfaces at specified writeIntervals, or, as in this case, use it as a postprocessing tool after completing your simulation. For instance, if your simulation has reached statistical convergence, you can save surfaces for 50 time directories as follows: goswami@ME:/mnt/f/Moving_Meshes_OFTest/Org/Org$ ls 0 4.56315 4.96315 5.36315 5.76315 6.16315 6.56315 6.96315 7.36315 7.76315 8.16315 4.24315 4.64315 5.04315 5.44315 5.84315 6.24315 6.64315 7.04315 7.44315 7.84315 constant 4.32315 4.72315 5.12315 5.52315 5.92315 6.32315 6.72315 7.12315 7.52315 7.92315 foam.foam 4.40315 4.80315 5.20315 5.60315 6.00315 6.40315 6.80315 7.20315 7.60315 8.00315 system 4.48315 4.88315 5.28315 5.68315 6.08315 6.48315 6.88315 7.28315 7.68315 8.08315 Once your case is set up, open an OpenFOAM-sourced terminal and execute the following command: pimpleFoam -postProcess -func surfaces This command will process the simulation results and write the pressure and velocity data for the specified slice at each time directory. The output will be stored in the &lt;Case&gt;/postProcessing/surfaces/ directory. A sample output might look like this: goswami@ME:/mnt/f/Moving_Meshes_OFTest/Org/Org/postProcessing/surfaces$ ls 4.24315 4.56315 4.88315 5.20315 5.52315 5.84315 6.16315 6.48315 6.80315 7.12315 7.44315 7.76315 8.08315 4.32315 4.64315 4.96315 5.28315 5.60315 5.92315 6.24315 6.56315 6.88315 7.20315 7.52315 7.84315 8.16315 4.40315 4.72315 5.04315 5.36315 5.68315 6.00315 6.32315 6.64315 6.96315 7.28315 7.60315 7.92315 4.48315 4.80315 5.12315 5.44315 5.76315 6.08315 6.40315 6.72315 7.04315 7.36315 7.68315 8.00315 Each time directory will contain files for the extracted surfaces. For example: goswami@ME:/mnt/f/Moving_Meshes_OFTest/Org/Org/postProcessing/surfaces$ tree 4.24315/ 4.24315/ └── zNormal.vtp Here, zNormal.vtp is the VTK file containing the pressure and velocity data for the slice at the specified time step. Now, let’s move to postprocessing in Python. Start by setting up the path variables and constants in your Jupyter notebook. These will help you organize and access the data efficiently in your analysis workflow. # Path Variables Path='F:/Moving_Meshes_OFTest/Org/Org/postProcessing/surfaces/' save_path='F:/Moving_Meshes_OFTest/Org/' save_Blog='F:/E_Drive/Blog_Posts/2025_Blogs/Blog9/' Files=os.listdir(Path) # Constants d=0.1 Ub=1 To begin, load the data from a single VTK file using the following code: Data=pv.read(Path + Files[0] + '/zNormal.vtp') grid=Data.points x=grid[:,0] y=grid[:,1] z=grid[:,2] rows, columns=np.shape(grid) print('rows = ', rows, 'columns = ', columns) To extract and compute the vorticity for all time steps, use PyVista within a loop. This approach enables the creation of a matrix containing the vorticity data: Data=pv.read(Path + Files[0] + '/zNormal.vtp') grid=Data.points x=grid[:,0] y=grid[:,1] z=grid[:,2] rows, columns=np.shape(grid) print('rows = ', rows, 'columns = ', columns) ### For U Snaps=len(Files) data_Vort=np.zeros((rows,Snaps-1)) grid_x=np.zeros((rows,Snaps-1)) grid_y=np.zeros((rows,Snaps-1)) grid_z=np.zeros((rows,Snaps-1)) for i in np.arange(0,Snaps-1): data=pv.read(Path + Files[i] + '/zNormal.vtp') grid=data.points grid_x[:,i:i+1] = np.reshape(grid[:,0], (rows,1), order='F') grid_y[:,i:i+1] = np.reshape(grid[:,1], (rows,1), order='F') grid_z[:,i:i+1] = np.reshape(grid[:,2], (rows,1), order='F') gradData=data.compute_derivative('U', vorticity=True) grad_pyvis=gradData.point_data['vorticity'] data_Vort[:,i:i+1] = np.reshape(grad_pyvis[:,2], (rows,1), order='F') np.save(save_path + 'VortZ.npy', data_Vort) np.save(save_path + 'grid_x.npy', grid_x) np.save(save_path + 'grid_y.npy', grid_y) np.save(save_path + 'grid_z.npy', grid_z) After extracting the data, visualize the vorticity field with a contour plot: Contour=0 A=0.05/0.1 Omega=2*np.pi fig, ax=plt.subplots(figsize=(11, 4)) p=ax.tricontourf(grid_x[:,Contour]/0.1, grid_y[:, Contour]/0.1, data_Vort[:,Contour]*(d/Ub), levels=1001, vmin=-1.8, vmax=1.8, cmap=cmap) patches=[] patches.append(plt.Rectangle((-0.5, (A*np.sin(Omega*float(Files[Contour])))-0.5), 1, 1, ec='k', color='white', zorder=2)) ax.add_patch(patches[0]) ax.xaxis.set_tick_params(direction='in', which='both') ax.yaxis.set_tick_params(direction='in', which='both') ax.xaxis.set_ticks_position('both') ax.yaxis.set_ticks_position('both') ax.set_xlim(-1, 20) ax.set_ylim(-5, 5) ax.set_aspect('equal') ax.set_xlabel(r'$x/d$') ax.set_ylabel(r'$y/d$') fig.set_tight_layout(True) plt.savefig(save_Blog + 'SqCylPlot.jpeg', dpi=600, bbox_inches='tight') plt.show() Since we are working with moving meshes, it’s crucial to account for the prescribed motion. For a sinusoidal motion, the position of the square cylinder at any time instant can be calculated using: \[X_c = A sin(\omega T)\] This enables precise positioning of the square cylinder patch in the plot. The same process can be followed for pure pitching and pure heaving simulations.]]></summary></entry><entry><title type="html">An Introduction to Overset Mesh in OpenFOAM</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-52/" rel="alternate" type="text/html" title="An Introduction to Overset Mesh in OpenFOAM"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-52</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-52/"><![CDATA[<p>Dynamic mesh motion is a critical feature in computational fluid dynamics (CFD) for simulating problems with moving boundaries or complex geometries. Among the various techniques available in OpenFOAM, the <strong>Overset mesh</strong> approach has gained popularity due to its flexibility in handling relative motion between different mesh regions. This method allows engineers and researchers to solve problems like rotor-stator interactions, aerodynamic analysis of moving vehicles, and more with enhanced accuracy and efficiency. In this blog, I’ll explore the fundamentals of Overset meshes in OpenFOAM.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog10/BlogLogo.gif" width="80%"/> </figure> <p>In the ever-evolving field of computational fluid dynamics (CFD), the ability to simulate moving boundaries and complex geometries accurately is a game-changer. Dynamic mesh motion plays a pivotal role in enabling such simulations, with applications ranging from simulating rotating machinery to analyzing the aerodynamics of moving vehicles. OpenFOAM offers multiple approaches for dynamic mesh motion, including mesh deformation, sliding interfaces, and Overset meshes. Among these, the Overset mesh approach stands out for its ability to handle large relative motions between mesh regions while maintaining computational efficiency and accuracy. This blog explores the Overset mesh method, offering insights into its working principles.</p> <p>Lets begin!!!</p> <h1 id="what-is-overset-mesh">What is Overset Mesh?</h1> <p>The Overset mesh approach, also known as Chimera mesh, is a numerical technique used in CFD to simulate problems involving complex, relative motion between different parts of a domain. Unlike traditional methods such as mesh deformation, where the grid is morphed to follow the motion, or sliding interfaces, which rely on aligned interfaces, Overset mesh employs overlapping grids to model the moving and stationary parts of the domain independently.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog10/OverSet.png" width="80%"/> </figure> <p>The Overset mesh approach operates on the principle of <em>overlapping grids</em>, which are independently defined and managed. These grids typically include a <em>stationary background grid</em> covering the entire computational domain and one or more <em>foreground grids</em> that move with the objects of interest. Unlike traditional methods, these grids do not need to conform to each other, allowing greater flexibility in simulating relative motions between different parts of the domain. The interaction between these grids is facilitated by <em>interpolation</em>. In the overlapping regions, field variables such as velocity and pressure are exchanged between grids through an interpolation process that ensures continuity and consistency of the solution across the domain.</p> <p>A key feature of the Overset mesh approach is <strong>hole cutting</strong>, where portions of the background mesh that lie within the physical boundaries of a moving object are deactivated or marked as <em>hole cells</em>. This ensures that the computational effort is focused only on the relevant parts of the domain. By keeping each mesh independent, the Overset method avoids common challenges such as grid deformation and interface alignment. This independence makes it particularly suitable for problems involving large displacements, rotations, or highly complex geometries, where traditional methods may struggle.</p> <h2 id="advantages-of-overset-mesh">Advantages of Overset Mesh</h2> <ul> <li><strong>Flexibility in Motion:</strong> Allows for arbitrary motions, including translations, rotations, or combinations thereof, without compromising mesh quality.</li> <li><strong>Ease of Grid Generation:</strong> Independent grids simplify the meshing process, especially for geometries with intricate shapes or components.</li> <li><strong>Reusability:</strong> Grids for moving parts can be reused across multiple simulations, saving time in preprocessing.</li> </ul> <h2 id="limitations">Limitations</h2> <ul> <li><strong>Computational Overhead:</strong> The interpolation process introduces additional computational cost.</li> <li><strong>Accuracy Concerns:</strong> Interpolation errors may arise, particularly in regions with steep gradients or inadequate grid resolution.</li> <li><strong>Complex Setup:</strong> Requires careful planning for grid placement, overlap, and boundary conditions to avoid solver instability.</li> </ul> <h2 id="comparison-with-other-techniques">Comparison with Other Techniques</h2> <p>The Overset mesh approach is particularly advantageous when other methods struggle, such as when simulating aircraft in flight, propeller blades, or moving objects in fluid flow.</p> <table> <thead> <tr> <th><strong>Feature</strong></th> <th><strong>Mesh Deformation</strong></th> <th><strong>Sliding Interfaces</strong></th> <th><strong>Overset Mesh</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Motion Flexibility</strong></td> <td>Limited to small deformations</td> <td>Restricted to specific planes</td> <td>Arbitrary large motions</td> </tr> <tr> <td><strong>Mesh Quality</strong></td> <td>Degrades with deformation</td> <td>Maintains quality</td> <td>Independent of motion</td> </tr> <tr> <td><strong>Setup Complexity</strong></td> <td>Moderate</td> <td>Low</td> <td>High</td> </tr> <tr> <td><strong>Computational Cost</strong></td> <td>Low</td> <td>Moderate</td> <td>High</td> </tr> <tr> <td><strong>Ideal Applications</strong></td> <td>Small displacements or deformations</td> <td>Rotating machinery with fixed planes</td> <td>Arbitrary motion of complex objects</td> </tr> </tbody> </table> <h1 id="how-does-overset-mesh-work-">How does Overset mesh work ?</h1> <figure> <img src="https://goswami-13.github.io/images/2025/Blog10/OS_Anim.gif" width="80%"/> </figure> <p>In overlapping regions, the grids communicate by exchanging information through interpolation. The cells providing this information are known as donor cells, while those receiving it are called receptor cells. This interpolation process ensures that the solution remains continuous and consistent across the grid interfaces, enabling accurate modeling of interactions between stationary and moving regions.</p> <p>An essential step in Overset mesh simulations is hole cutting. In this process, the solver identifies and deactivates portions of the background grid that fall within the physical boundaries of a moving object. These deactivated cells, referred to as hole cells, are excluded from the computation to avoid redundant calculations. Hole cutting allows the solution to focus computational resources on the active cells of the foreground grid, ensuring efficiency.</p> <p>The governing equations, such as the Navier-Stokes equations, are solved on both the background and foreground grids simultaneously. At every time step, data is exchanged dynamically through interpolation in overlapping regions, which allows the motion of the foreground grid to be seamlessly integrated with the stationary background grid. This approach enables the simulation of various types of dynamic motions, including translation, rotation, and complex combinations of the two. Unlike traditional methods, Overset meshes avoid grid distortion or alignment challenges, making them ideal for problems involving large displacements or rotations.</p> <p>Boundary conditions play a crucial role in maintaining the accuracy and stability of the solution. They are carefully applied at grid interfaces (overlapping regions) and physical boundaries (such as inlets, outlets, and walls). Proper management of these conditions ensures that the physical integrity of the simulation is preserved, even in complex scenarios.</p>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[Dynamic mesh motion is a critical feature in computational fluid dynamics (CFD) for simulating problems with moving boundaries or complex geometries. Among the various techniques available in OpenFOAM, the Overset mesh approach has gained popularity due to its flexibility in handling relative motion between different mesh regions. This method allows engineers and researchers to solve problems like rotor-stator interactions, aerodynamic analysis of moving vehicles, and more with enhanced accuracy and efficiency. In this blog, I’ll explore the fundamentals of Overset meshes in OpenFOAM. In the ever-evolving field of computational fluid dynamics (CFD), the ability to simulate moving boundaries and complex geometries accurately is a game-changer. Dynamic mesh motion plays a pivotal role in enabling such simulations, with applications ranging from simulating rotating machinery to analyzing the aerodynamics of moving vehicles. OpenFOAM offers multiple approaches for dynamic mesh motion, including mesh deformation, sliding interfaces, and Overset meshes. Among these, the Overset mesh approach stands out for its ability to handle large relative motions between mesh regions while maintaining computational efficiency and accuracy. This blog explores the Overset mesh method, offering insights into its working principles. Lets begin!!! What is Overset Mesh? The Overset mesh approach, also known as Chimera mesh, is a numerical technique used in CFD to simulate problems involving complex, relative motion between different parts of a domain. Unlike traditional methods such as mesh deformation, where the grid is morphed to follow the motion, or sliding interfaces, which rely on aligned interfaces, Overset mesh employs overlapping grids to model the moving and stationary parts of the domain independently. The Overset mesh approach operates on the principle of overlapping grids, which are independently defined and managed. These grids typically include a stationary background grid covering the entire computational domain and one or more foreground grids that move with the objects of interest. Unlike traditional methods, these grids do not need to conform to each other, allowing greater flexibility in simulating relative motions between different parts of the domain. The interaction between these grids is facilitated by interpolation. In the overlapping regions, field variables such as velocity and pressure are exchanged between grids through an interpolation process that ensures continuity and consistency of the solution across the domain. A key feature of the Overset mesh approach is hole cutting, where portions of the background mesh that lie within the physical boundaries of a moving object are deactivated or marked as hole cells. This ensures that the computational effort is focused only on the relevant parts of the domain. By keeping each mesh independent, the Overset method avoids common challenges such as grid deformation and interface alignment. This independence makes it particularly suitable for problems involving large displacements, rotations, or highly complex geometries, where traditional methods may struggle. Advantages of Overset Mesh Flexibility in Motion: Allows for arbitrary motions, including translations, rotations, or combinations thereof, without compromising mesh quality. Ease of Grid Generation: Independent grids simplify the meshing process, especially for geometries with intricate shapes or components. Reusability: Grids for moving parts can be reused across multiple simulations, saving time in preprocessing. Limitations Computational Overhead: The interpolation process introduces additional computational cost. Accuracy Concerns: Interpolation errors may arise, particularly in regions with steep gradients or inadequate grid resolution. Complex Setup: Requires careful planning for grid placement, overlap, and boundary conditions to avoid solver instability. Comparison with Other Techniques The Overset mesh approach is particularly advantageous when other methods struggle, such as when simulating aircraft in flight, propeller blades, or moving objects in fluid flow. Feature Mesh Deformation Sliding Interfaces Overset Mesh Motion Flexibility Limited to small deformations Restricted to specific planes Arbitrary large motions Mesh Quality Degrades with deformation Maintains quality Independent of motion Setup Complexity Moderate Low High Computational Cost Low Moderate High Ideal Applications Small displacements or deformations Rotating machinery with fixed planes Arbitrary motion of complex objects How does Overset mesh work ? In overlapping regions, the grids communicate by exchanging information through interpolation. The cells providing this information are known as donor cells, while those receiving it are called receptor cells. This interpolation process ensures that the solution remains continuous and consistent across the grid interfaces, enabling accurate modeling of interactions between stationary and moving regions. An essential step in Overset mesh simulations is hole cutting. In this process, the solver identifies and deactivates portions of the background grid that fall within the physical boundaries of a moving object. These deactivated cells, referred to as hole cells, are excluded from the computation to avoid redundant calculations. Hole cutting allows the solution to focus computational resources on the active cells of the foreground grid, ensuring efficiency. The governing equations, such as the Navier-Stokes equations, are solved on both the background and foreground grids simultaneously. At every time step, data is exchanged dynamically through interpolation in overlapping regions, which allows the motion of the foreground grid to be seamlessly integrated with the stationary background grid. This approach enables the simulation of various types of dynamic motions, including translation, rotation, and complex combinations of the two. Unlike traditional methods, Overset meshes avoid grid distortion or alignment challenges, making them ideal for problems involving large displacements or rotations. Boundary conditions play a crucial role in maintaining the accuracy and stability of the solution. They are carefully applied at grid interfaces (overlapping regions) and physical boundaries (such as inlets, outlets, and walls). Proper management of these conditions ensures that the physical integrity of the simulation is preserved, even in complex scenarios.]]></summary></entry><entry><title type="html">Setting Up Overset Mesh Cases in OpenFOAM Made Easy</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-53/" rel="alternate" type="text/html" title="Setting Up Overset Mesh Cases in OpenFOAM Made Easy"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-53</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/06/blog-post-53/"><![CDATA[<p>Overset mesh, also known as chimera or overlapping grid, is a powerful technique in CFD for handling complex geometries and moving bodies without remeshing. This capability in OpenFOAM simplifies simulations involving relative motion between components, such as propellers or rotor-stator interactions. In this article, I will explore the step-by-step process of setting up an overset mesh case in OpenFOAM, focusing on essential parameters, best practices, and potential pitfalls.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog11/BlogLogo.gif" width="80%"/> </figure> <p>Overset mesh, often referred to as chimera mesh, is a groundbreaking approach in Computational Fluid Dynamics (CFD) for handling simulations involving complex geometries or relative motions between components. Unlike traditional meshing techniques, overset meshing enables overlapping grids, allowing seamless movement of components without the need for remeshing. In this blog, we build on the fundamentals and working principles <a href="https://medium.com/@goswami13/introduction-to-overset-mesh-in-openfoam-ec607872c23f">discussed in my earlier article</a> and dive into the practical aspects of setting up an overset mesh case in OpenFOAM.</p> <p>To demonstrate the setup and capabilities of the overset mesh motion approach, I will use the example of an oscillating square cylinder with a prescribed frequency. This motion closely resembles the prescribed mesh motion case discussed in an earlier post. To follow along with this tutorial, you can download the case files from my GitHub repository <a href="https://github.com/goswami-13/Overset_Base">here</a>.</p> <p>Lets begin!!!</p> <h1 id="fundamentals-of-overset-mesh">Fundamentals of Overset mesh</h1> <p>Before we get into the details of the setup process, let’s quickly revisit the basics. Overset meshing involves the use of two or more grids: a background grid and one or more overlapping grids. These grids interact through interpolation, enabling seamless data transfer across grid boundaries. This approach is particularly effective for simulating scenarios involving moving bodies, such as oscillating cylinders, rotating machinery, or dynamic geometries. For a deeper dive into the theory behind overset meshing, feel free to refer to my earlier article.</p> <p>In this tutorial, we’ll work with one background grid and one overlapping grid. The background grid is a simple structured grid with localized refinement in the center, designed to accommodate the square cylinder and the overlapping grid. Here’s a visualization of the background grid:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog11/BackgroundGrid.png" width="80%"/> </figure> <p>The overset grid is a uniform grid centered around the square cylinder, and it looks like this:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog11/OversetGrid.png" width="80%"/> </figure> <p>When designing the grids, the size of the background grid must ensure that the side and top boundaries have minimal impact on the wake development. Similarly, the overset grid should typically be a square or C-shaped domain with uniform spacing around the region of interest (in this case, the square cylinder). These considerations are critical for accurately capturing wake dynamics without interference from boundary effects.</p> <p>If you’re unsure about your domain dimensions or wake behavior, consulting literature or research articles related to vortex dynamics and wake flows can provide helpful guidance. After all, references exist for a reason, right?</p> <h1 id="case-setup">Case Setup</h1> <p>The first step in setting up an overset case is organizing the case directory. For an overset mesh simulation, the case directory should include two primary subfolders: background and overset. Organizing the case directory in this manner ensures a clean and modular workflow, making it easier to set up, modify, and debug overset simulations.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog11/Folders.png" width="80%"/> </figure> <p>The contents of this folder should be as such:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OverSet_Base/
├── background
│   ├── 0
│   │   ├── U
│   │   ├── p
│   │   ├── pointDisplacement
│   │   └── zoneID.gz
│   ├── Background.msh
│   ├── constant
│   │   ├── dynamicMeshDict
│   │   ├── transportProperties
│   │   └── turbulenceProperties
│   └── system
│       ├── MultipleLines
│       ├── controlDict
│       ├── decomposeParDict
│       ├── fvSchemes
│       ├── fvSolution
│       ├── probes
│       ├── surfaces
│       ├── topoSetDict
└── overset
    ├── Square.msh
    ├── constant
    │   ├── dynamicMeshDict
    │   ├── transportProperties
    │   └── turbulenceProperties
    └── system
        ├── MultipleLines
        ├── controlDict
        ├── decomposeParDict
        ├── fvSchemes
        ├── fvSolution
        ├── probes
        └── surfaces
</code></pre></div></div> <p>The background folder serves as the primary simulation directory, housing the background mesh and all simulation settings, including boundary conditions. This is where most of the case-specific configurations will be defined. In contrast, the overset folder should only contain the overset mesh file along with the <code class="language-plaintext highlighter-rouge">constant</code> and <code class="language-plaintext highlighter-rouge">system</code> subdirectories required for its setup.</p> <p>To properly configure an overset mesh case in OpenFOAM, five main requirements must be addressed:</p> <ol> <li>Setup of the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/system/topoSetDict</code> file: This file defines the interpolation zones for overset meshing.</li> <li>Configuration of the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/0/zoneID</code> boundary condition: Specifies the zone IDs to link the background and overset grids.</li> <li>Definition of motion within the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/constant/dynamicMeshDict</code> file: Contains settings for mesh motion and dynamics.</li> <li>Motion boundary conditions in the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/0/</code> directory: Boundary conditions for the moving body or overset grid must be defined here.</li> <li>Overset mesh solver settings: Configures the solver to handle overset interpolation and motion dynamics.</li> </ol> <p>Each of these components is essential for ensuring the correct functionality of an overset mesh case. Let’s explore these setup requirements in detail, step by step.</p> <h2 id="setting-up-of-toposetdict-file">Setting up of topoSetDict file</h2> <p>In the overset mesh approach, the simulation combines two meshes, the background and the overset mesh. To facilitate this integration, cell zones must be defined to distinguish between the two mesh regions. This is achieved using the <code class="language-plaintext highlighter-rouge">topoSetDict</code> file.</p> <p>The <code class="language-plaintext highlighter-rouge">topoSetDict</code> file, located in <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/system/</code>, should be configured as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2412                                 |
|   <span class="se">\\</span>  /    A nd           | Website:  www.openfoam.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
    version     1.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       dictionary<span class="p">;</span>
    object      topoSetDict<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //
actions
<span class="o">(</span>
    <span class="o">{</span>
        name    OSGrid<span class="p">;</span>
        <span class="nb">type    </span>cellSet<span class="p">;</span>
        action  new<span class="p">;</span>
        <span class="nb">source  </span>regionToCell<span class="p">;</span>
        insidePoints <span class="o">((</span>0.15 0.15 0<span class="o">))</span><span class="p">;</span>
    <span class="o">}</span>
    <span class="o">{</span>
        name    BGGrid<span class="p">;</span>
        <span class="nb">type    </span>cellSet<span class="p">;</span>
        action  new<span class="p">;</span>
        <span class="nb">source  </span>cellToCell<span class="p">;</span>
        <span class="nb">set     </span>OSGrid<span class="p">;</span>
    <span class="o">}</span>
    <span class="o">{</span>
        name    BGGrid<span class="p">;</span>
        <span class="nb">type    </span>cellSet<span class="p">;</span>
        action  invert<span class="p">;</span>
    <span class="o">}</span>
<span class="o">)</span><span class="p">;</span>
// <span class="k">*************************************************************************</span> //

</code></pre></div></div> <p>Now, let’s break down what’s happening in the <code class="language-plaintext highlighter-rouge">topoSetDict</code> file:</p> <ol> <li>The first action defines a <code class="language-plaintext highlighter-rouge">cellSet</code> named <code class="language-plaintext highlighter-rouge">OSGrid</code>, which identifies the region of cells within the overset zone. This essentially marks the cells belonging to the overlapping grid.</li> <li>Next, another <code class="language-plaintext highlighter-rouge">cellSet</code> named <code class="language-plaintext highlighter-rouge">BGGrid</code> is defined, representing the background mesh region.</li> <li>Finally, the <code class="language-plaintext highlighter-rouge">invert</code> action specifies that all cells not belonging to the <code class="language-plaintext highlighter-rouge">OSGrid</code> are included in the <code class="language-plaintext highlighter-rouge">BGGrid</code>.</li> </ol> <p>At this stage, two distinct cell sets <code class="language-plaintext highlighter-rouge">OSGrid</code> and <code class="language-plaintext highlighter-rouge">BGGrid</code> are established, laying the foundation for seamless interaction between the background and overset grids.</p> <h2 id="setting-up-the-zoneid">Setting up the zoneID</h2> <p>The <code class="language-plaintext highlighter-rouge">zoneID</code> is used to distinguish between the two cell sets defined earlier. This identification is critical for proper interpolation and data transfer between the grids. Using the setFields utility, we can assign unique IDs to the different cell sets.</p> <p>To do this, you’ll need to configure the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/system/setFieldsDict</code> file as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2412                                 |
|   <span class="se">\\</span>  /    A nd           | Website:  www.openfoam.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
    version     1.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       dictionary<span class="p">;</span>
    object      setFieldsDict<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //
defaultFieldValues
<span class="o">(</span>
    volScalarFieldValue zoneID 123
<span class="o">)</span><span class="p">;</span>
regions
<span class="o">(</span>
    cellToCell
    <span class="o">{</span>
        <span class="nb">set </span>OSGrid<span class="p">;</span>

        fieldValues
        <span class="o">(</span>
            volScalarFieldValue zoneID 0
        <span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>

    cellToCell
    <span class="o">{</span>
        <span class="nb">set </span>BGGrid<span class="p">;</span>

        fieldValues
        <span class="o">(</span>
            volScalarFieldValue zoneID 1
        <span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">)</span><span class="p">;</span>
// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <p>This file specifies two distinct regions and assigns unique zoneIDs to the cells within each. Additionally, a <code class="language-plaintext highlighter-rouge">zeroGradient</code> boundary condition is applied to all boundaries, ensuring continuity between the zones.</p> <h2 id="defining-the-motion">Defining the motion</h2> <p>The next step involves defining the motion within the <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code> file. This process closely resembles the setup for the prescribed mesh deformation case discussed earlier. In this instance, we will use the <code class="language-plaintext highlighter-rouge">dynamicOversetFvMesh</code> library to handle the overset mesh motion. To prescribe the motion, the <code class="language-plaintext highlighter-rouge">multiSolidBodyMotionSolver</code> is employed. The motion itself is defined based on the <code class="language-plaintext highlighter-rouge">oscillatingLinearMotion</code> properties, which include parameters for the amplitude and frequency of oscillation. For this case, we simulate the heaving motion of a square cylinder with the following properties:</p> <ul> <li>Amplitude: 0.05</li> <li>Angular frequency (𝜔): 6.28318</li> </ul> <p>The <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/background/constant/dynamicMeshDict</code> file is configured as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2412                                 |
|   <span class="se">\\</span>  /    A nd           | Website:  www.openfoam.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
	version     1.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       dictionary<span class="p">;</span>
    object      dynamicMeshDict<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //

dynamicFvMesh       dynamicOversetFvMesh<span class="p">;</span>

dynamicOversetFvMeshCoeffs
<span class="o">{</span>
//    layerRelax 0.3<span class="p">;</span>
<span class="o">}</span>

solver          multiSolidBodyMotionSolver<span class="p">;</span>

multiSolidBodyMotionSolverCoeffs
<span class="o">{</span>
    movingZone
    <span class="o">{</span>
        solidBodyMotionFunction oscillatingLinearMotion<span class="p">;</span>
         amplitude       <span class="o">(</span> 0 0.05 0 <span class="o">)</span><span class="p">;</span>
        omega           6.28318<span class="p">;</span>
        value           uniform <span class="o">(</span> 0 0 0 <span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <p>Once the motion is defined, the next step is to specify the region where this motion will be applied. While the cellSet containing the overset and background meshes has already been defined, we now need to create an additional region or zone for the moving body. To accomplish this, we use another <code class="language-plaintext highlighter-rouge">topoSetDict</code> file, named <code class="language-plaintext highlighter-rouge">topoSetDict_movingZone</code>, to define a cellZone within the <code class="language-plaintext highlighter-rouge">BGGrid</code> cell set. This zone will encapsulate the region where the prescribed motion will be applied. The new <code class="language-plaintext highlighter-rouge">topoSetDict_movingZone</code> file should be configured as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2412                                 |
|   <span class="se">\\</span>  /    A nd           | Website:  www.openfoam.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
	version     1.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       dictionary<span class="p">;</span>
    object      topoSetDict<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //
actions
<span class="o">(</span>
    <span class="o">{</span>
        name    movingZone<span class="p">;</span>
        <span class="nb">type    </span>cellZoneSet<span class="p">;</span>
        action  new<span class="p">;</span>
        <span class="nb">source  </span>setToCellZone<span class="p">;</span>
        sourceInfo
        <span class="o">{</span>
            <span class="nb">set </span>BGGrid<span class="p">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">)</span><span class="p">;</span>
// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <h2 id="setting-up-the-overset-boundary-conditions">Setting up the overset boundary conditions</h2> <p>Next, we define the boundary conditions within the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/0/</code> folder for the U, p, and pointDisplacement files. These conditions will include an additional boundary named OVERSET, which applies the <code class="language-plaintext highlighter-rouge">overset</code> boundary condition. This setup facilitates seamless information exchange between the background and overset meshes.</p> <p>For the velocity field, the overset region will be specified with the <code class="language-plaintext highlighter-rouge">overset</code> boundary condition, and the square cylinder will have a <code class="language-plaintext highlighter-rouge">movingWallVelocity</code> condition as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
	  OVERSET
    <span class="o">{</span>
        <span class="nb">type                      </span>overset<span class="p">;</span>
    <span class="o">}</span>

    PRISM
    <span class="o">{</span>
        <span class="nb">type                      </span>movingWallVelocity<span class="p">;</span>
		value                     uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
</code></pre></div></div> <p>For pressure, the overset region will again use the <code class="language-plaintext highlighter-rouge">overset</code> boundary condition, while the square cylinder will have a <code class="language-plaintext highlighter-rouge">zeroGradient</code> condition:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
	  OVERSET
    <span class="o">{</span>      
        <span class="nb">type            </span>overset<span class="p">;</span>
    <span class="o">}</span>

    PRISM
    <span class="o">{</span>
        <span class="nb">type                      </span>zeroGradient <span class="p">;</span>
    <span class="o">}</span>
</code></pre></div></div> <p>For the <code class="language-plaintext highlighter-rouge">pointDisplacement</code> file, the overset patch will use a <code class="language-plaintext highlighter-rouge">zeroGradient</code> condition, and the square cylinder will use a <code class="language-plaintext highlighter-rouge">calculated</code> condition:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
	  OVERSET
    <span class="o">{</span>      
        patchType       overset<span class="p">;</span>
        <span class="nb">type            </span>zeroGradient<span class="p">;</span>
    <span class="o">}</span>

    PRISM
    <span class="o">{</span>
        <span class="nb">type            </span>calculated<span class="p">;</span>
        value           uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
</code></pre></div></div> <h2 id="overset-mesh-solver-settings">Overset mesh solver settings</h2> <p>Finally, the solver settings for the simulation are defined in the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/system/fvSchemes</code> file. The configuration should look as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ddtSchemes
<span class="o">{</span>
    default         backward<span class="p">;</span>
<span class="o">}</span>

gradSchemes
<span class="o">{</span>
    default         cellLimited Gauss linear 1<span class="p">;</span>
<span class="o">}</span>

divSchemes
<span class="o">{</span>
    default         none<span class="p">;</span>
    div<span class="o">(</span>phi,U<span class="o">)</span>      Gauss linearUpwind grad<span class="o">(</span>U<span class="o">)</span><span class="p">;</span>
    div<span class="o">((</span>nuEff<span class="k">*</span>dev2<span class="o">(</span>T<span class="o">(</span>grad<span class="o">(</span>U<span class="o">)))))</span> Gauss linear<span class="p">;</span>
<span class="o">}</span>

laplacianSchemes
<span class="o">{</span>
    default         Gauss linear limited 1<span class="p">;</span>
<span class="o">}</span>

interpolationSchemes
<span class="o">{</span>
    default         linear<span class="p">;</span>
<span class="o">}</span>

snGradSchemes
<span class="o">{</span>
    default         limited 1<span class="p">;</span>
<span class="o">}</span>

wallDist
<span class="o">{</span>
    method          meshWave<span class="p">;</span>
<span class="o">}</span>

oversetInterpolation
<span class="o">{</span>
    method              inverseDistance<span class="p">;</span>
<span class="o">}</span>

fluxRequired
<span class="o">{</span>
    default         no<span class="p">;</span>
    pcorr           <span class="p">;</span>
    p               <span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>In this setup, particular emphasis is placed on defining the interpolation method. For this tutorial, the <code class="language-plaintext highlighter-rouge">inverseDistance</code> method has been selected to ensure accurate data transfer between the background and overset meshes.</p> <h1 id="running-the-case">Running the case</h1> <p>Running the overset case is not straight-forward as running any other case. This is because we specified couple of <code class="language-plaintext highlighter-rouge">topoSetDict</code> files and one <code class="language-plaintext highlighter-rouge">setFieldsDict</code>. As such, here are the steps to run the case:</p> <h2 id="step-1-mesh-generation">Step 1: Mesh Generation</h2> <p>First, generate the meshes for both the background and overset grids by navigating into the corresponding directories and running the <code class="language-plaintext highlighter-rouge">fluent3DMeshToFoam</code> utility:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>background/
fluent3DMeshToFoam Background.msh
<span class="nb">cd</span> ../overset/
fluent3DMeshToFoam Square.msh
<span class="nb">cd</span> ../background/
</code></pre></div></div> <h2 id="step-2-merging-the-meshes">Step 2: Merging the Meshes</h2> <p>Since overset mesh operates on overlapping grids, the next step is to merge the two meshes. This is done using the <code class="language-plaintext highlighter-rouge">mergeMeshes</code> utility, and it should be executed from within the background directory:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mergeMeshes <span class="nb">.</span> ../overset/ <span class="nt">-overwrite</span>
</code></pre></div></div> <p>After running this command, OpenFOAM will generate 8 patches, as indicated below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>patch names: 8<span class="o">(</span>INLET OUTLET TOP BOTTOM SIDE1 SIDE2 PRISM OVERSET<span class="o">)</span>
</code></pre></div></div> <p><strong>From this point forward, all operations will be conducted within the background directory.</strong></p> <h2 id="step-3-defining-regions-and-zone-ids">Step 3: Defining Regions and Zone IDs</h2> <p>At this point, we have a merged mesh containing both the overset and background meshes. The next task is to define the different regions and zoneIDs as previously mentioned. To do this, run the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>topoSet
</code></pre></div></div> <p>This will create the two cell sets. Next, define the <code class="language-plaintext highlighter-rouge">zoneID</code>. You will need to create a file called <code class="language-plaintext highlighter-rouge">zoneID</code> in the <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/0/</code> directory with the following content:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2412                                 |
|   <span class="se">\\</span>  /    A nd           | Website:  www.openfoam.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
    version     1.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       volScalarField<span class="p">;</span>
    object      zoneID<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //

dimensions      <span class="o">[</span>0 0 0 0 0 0 0]<span class="p">;</span>

internalField   uniform 0<span class="p">;</span>

boundaryField
<span class="o">{</span>
    overset
    <span class="o">{</span>
        <span class="nb">type            </span>overset<span class="p">;</span>
        value           uniform 0<span class="p">;</span>
    <span class="o">}</span>

    <span class="s2">".*"</span>
    <span class="o">{</span>
        <span class="nb">type            </span>zeroGradient<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <p>Run the following command to assign the <code class="language-plaintext highlighter-rouge">zoneID</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setFields
</code></pre></div></div> <p>This step is crucial as it ensures that the overset zones are properly defined.</p> <h2 id="step-4-defining-the-moving-zone">Step 4: Defining the Moving Zone</h2> <p>Next, we define the moving zone. This can be done by running another <code class="language-plaintext highlighter-rouge">topoSet</code> command, but this time using the <code class="language-plaintext highlighter-rouge">topoSetDict_movingZone</code> file. To define the moving zone, use:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>topoSet <span class="nt">-dict</span> system/topoSetDict_movingZone
</code></pre></div></div> <h2 id="step-5-solver-setup">Step 5: Solver Setup</h2> <p>At this point, we are almost ready to run the simulation. First, update the <code class="language-plaintext highlighter-rouge">controlDict</code> file to specify the <code class="language-plaintext highlighter-rouge">writeInterval</code> and <code class="language-plaintext highlighter-rouge">endTime</code> for your simulation, as shown below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2412                                 |
|   <span class="se">\\</span>  /    A nd           | Web:      www.OpenFOAM.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
    version     2.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       dictionary<span class="p">;</span>
    object      controlDict<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //

libs
<span class="o">(</span>
<span class="s2">"petscFoam"</span>
<span class="s2">"overset"</span> 
<span class="s2">"fvMotionSolvers"</span>
<span class="o">)</span><span class="p">;</span>

application     overPimpleDyMFoam<span class="p">;</span>//pimpleFoam<span class="p">;</span>

startFrom       latestTime<span class="p">;</span>//startTime<span class="p">;</span>

startTime       0<span class="p">;</span>

stopAt          endTime<span class="p">;</span>

endTime         2<span class="p">;</span> // 20 Through <span class="nb">times

</span>deltaT          0.005<span class="p">;</span>

writeControl    timeStep<span class="p">;</span>

writeInterval   10<span class="p">;</span>

purgeWrite      0<span class="p">;</span>

writeFormat     ascii<span class="p">;</span>

writePrecision  8<span class="p">;</span>

writeCompression on<span class="p">;</span>

timeFormat      general<span class="p">;</span>

timePrecision   8<span class="p">;</span>

runTimeModifiable <span class="nb">true</span><span class="p">;</span>

// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <p>Finally, run the solver with the following command in your terminal:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>overPimpleDyMFoam
</code></pre></div></div> <p><strong>Note:</strong> If you’re running a 2D case, ensure you specify empty patches for the side boundaries in <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/constant/polyMesh/boundary</code> and <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/0/zoneID</code>. Also, specify the <code class="language-plaintext highlighter-rouge">overset</code> boundary type for the overset patch in <code class="language-plaintext highlighter-rouge">&lt;Case&gt;/constant/polyMesh/boundary</code>.</p> <p>To animate the mesh motion, you can use the <code class="language-plaintext highlighter-rouge">moveDynamicMesh</code> utility.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog11/AnimOS.gif" width="80%"/> </figure>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[Overset mesh, also known as chimera or overlapping grid, is a powerful technique in CFD for handling complex geometries and moving bodies without remeshing. This capability in OpenFOAM simplifies simulations involving relative motion between components, such as propellers or rotor-stator interactions. In this article, I will explore the step-by-step process of setting up an overset mesh case in OpenFOAM, focusing on essential parameters, best practices, and potential pitfalls. Overset mesh, often referred to as chimera mesh, is a groundbreaking approach in Computational Fluid Dynamics (CFD) for handling simulations involving complex geometries or relative motions between components. Unlike traditional meshing techniques, overset meshing enables overlapping grids, allowing seamless movement of components without the need for remeshing. In this blog, we build on the fundamentals and working principles discussed in my earlier article and dive into the practical aspects of setting up an overset mesh case in OpenFOAM. To demonstrate the setup and capabilities of the overset mesh motion approach, I will use the example of an oscillating square cylinder with a prescribed frequency. This motion closely resembles the prescribed mesh motion case discussed in an earlier post. To follow along with this tutorial, you can download the case files from my GitHub repository here. Lets begin!!! Fundamentals of Overset mesh Before we get into the details of the setup process, let’s quickly revisit the basics. Overset meshing involves the use of two or more grids: a background grid and one or more overlapping grids. These grids interact through interpolation, enabling seamless data transfer across grid boundaries. This approach is particularly effective for simulating scenarios involving moving bodies, such as oscillating cylinders, rotating machinery, or dynamic geometries. For a deeper dive into the theory behind overset meshing, feel free to refer to my earlier article. In this tutorial, we’ll work with one background grid and one overlapping grid. The background grid is a simple structured grid with localized refinement in the center, designed to accommodate the square cylinder and the overlapping grid. Here’s a visualization of the background grid: The overset grid is a uniform grid centered around the square cylinder, and it looks like this: When designing the grids, the size of the background grid must ensure that the side and top boundaries have minimal impact on the wake development. Similarly, the overset grid should typically be a square or C-shaped domain with uniform spacing around the region of interest (in this case, the square cylinder). These considerations are critical for accurately capturing wake dynamics without interference from boundary effects. If you’re unsure about your domain dimensions or wake behavior, consulting literature or research articles related to vortex dynamics and wake flows can provide helpful guidance. After all, references exist for a reason, right? Case Setup The first step in setting up an overset case is organizing the case directory. For an overset mesh simulation, the case directory should include two primary subfolders: background and overset. Organizing the case directory in this manner ensures a clean and modular workflow, making it easier to set up, modify, and debug overset simulations. The contents of this folder should be as such: OverSet_Base/ ├── background │   ├── 0 │   │   ├── U │   │   ├── p │   │   ├── pointDisplacement │   │   └── zoneID.gz │   ├── Background.msh │   ├── constant │   │   ├── dynamicMeshDict │   │   ├── transportProperties │   │   └── turbulenceProperties │   └── system │   ├── MultipleLines │   ├── controlDict │   ├── decomposeParDict │   ├── fvSchemes │   ├── fvSolution │   ├── probes │   ├── surfaces │   ├── topoSetDict └── overset ├── Square.msh ├── constant │   ├── dynamicMeshDict │   ├── transportProperties │   └── turbulenceProperties └── system ├── MultipleLines ├── controlDict ├── decomposeParDict ├── fvSchemes ├── fvSolution ├── probes └── surfaces The background folder serves as the primary simulation directory, housing the background mesh and all simulation settings, including boundary conditions. This is where most of the case-specific configurations will be defined. In contrast, the overset folder should only contain the overset mesh file along with the constant and system subdirectories required for its setup. To properly configure an overset mesh case in OpenFOAM, five main requirements must be addressed: Setup of the &lt;Case&gt;/background/system/topoSetDict file: This file defines the interpolation zones for overset meshing. Configuration of the &lt;Case&gt;/background/0/zoneID boundary condition: Specifies the zone IDs to link the background and overset grids. Definition of motion within the &lt;Case&gt;/background/constant/dynamicMeshDict file: Contains settings for mesh motion and dynamics. Motion boundary conditions in the &lt;Case&gt;/background/0/ directory: Boundary conditions for the moving body or overset grid must be defined here. Overset mesh solver settings: Configures the solver to handle overset interpolation and motion dynamics. Each of these components is essential for ensuring the correct functionality of an overset mesh case. Let’s explore these setup requirements in detail, step by step. Setting up of topoSetDict file In the overset mesh approach, the simulation combines two meshes, the background and the overset mesh. To facilitate this integration, cell zones must be defined to distinguish between the two mesh regions. This is achieved using the topoSetDict file. The topoSetDict file, located in &lt;Case&gt;/background/system/, should be configured as follows: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Website: www.openfoam.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 1.0; format ascii; class dictionary; object topoSetDict; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // actions ( { name OSGrid; type cellSet; action new; source regionToCell; insidePoints ((0.15 0.15 0)); } { name BGGrid; type cellSet; action new; source cellToCell; set OSGrid; } { name BGGrid; type cellSet; action invert; } ); // ************************************************************************* // Now, let’s break down what’s happening in the topoSetDict file: The first action defines a cellSet named OSGrid, which identifies the region of cells within the overset zone. This essentially marks the cells belonging to the overlapping grid. Next, another cellSet named BGGrid is defined, representing the background mesh region. Finally, the invert action specifies that all cells not belonging to the OSGrid are included in the BGGrid. At this stage, two distinct cell sets OSGrid and BGGrid are established, laying the foundation for seamless interaction between the background and overset grids. Setting up the zoneID The zoneID is used to distinguish between the two cell sets defined earlier. This identification is critical for proper interpolation and data transfer between the grids. Using the setFields utility, we can assign unique IDs to the different cell sets. To do this, you’ll need to configure the &lt;Case&gt;/background/system/setFieldsDict file as follows: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Website: www.openfoam.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 1.0; format ascii; class dictionary; object setFieldsDict; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // defaultFieldValues ( volScalarFieldValue zoneID 123 ); regions ( cellToCell { set OSGrid; fieldValues ( volScalarFieldValue zoneID 0 ); } cellToCell { set BGGrid; fieldValues ( volScalarFieldValue zoneID 1 ); } ); // ************************************************************************* // This file specifies two distinct regions and assigns unique zoneIDs to the cells within each. Additionally, a zeroGradient boundary condition is applied to all boundaries, ensuring continuity between the zones. Defining the motion The next step involves defining the motion within the dynamicMeshDict file. This process closely resembles the setup for the prescribed mesh deformation case discussed earlier. In this instance, we will use the dynamicOversetFvMesh library to handle the overset mesh motion. To prescribe the motion, the multiSolidBodyMotionSolver is employed. The motion itself is defined based on the oscillatingLinearMotion properties, which include parameters for the amplitude and frequency of oscillation. For this case, we simulate the heaving motion of a square cylinder with the following properties: Amplitude: 0.05 Angular frequency (𝜔): 6.28318 The &lt;Case&gt;/background/constant/dynamicMeshDict file is configured as follows: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Website: www.openfoam.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 1.0; format ascii; class dictionary; object dynamicMeshDict; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dynamicFvMesh dynamicOversetFvMesh; dynamicOversetFvMeshCoeffs { // layerRelax 0.3; } solver multiSolidBodyMotionSolver; multiSolidBodyMotionSolverCoeffs { movingZone { solidBodyMotionFunction oscillatingLinearMotion; amplitude ( 0 0.05 0 ); omega 6.28318; value uniform ( 0 0 0 ); } } // ************************************************************************* // Once the motion is defined, the next step is to specify the region where this motion will be applied. While the cellSet containing the overset and background meshes has already been defined, we now need to create an additional region or zone for the moving body. To accomplish this, we use another topoSetDict file, named topoSetDict_movingZone, to define a cellZone within the BGGrid cell set. This zone will encapsulate the region where the prescribed motion will be applied. The new topoSetDict_movingZone file should be configured as follows: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Website: www.openfoam.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 1.0; format ascii; class dictionary; object topoSetDict; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // actions ( { name movingZone; type cellZoneSet; action new; source setToCellZone; sourceInfo { set BGGrid; } } ); // ************************************************************************* // Setting up the overset boundary conditions Next, we define the boundary conditions within the &lt;Case&gt;/0/ folder for the U, p, and pointDisplacement files. These conditions will include an additional boundary named OVERSET, which applies the overset boundary condition. This setup facilitates seamless information exchange between the background and overset meshes. For the velocity field, the overset region will be specified with the overset boundary condition, and the square cylinder will have a movingWallVelocity condition as follows: ... OVERSET { type overset; } PRISM { type movingWallVelocity; value uniform (0 0 0); } For pressure, the overset region will again use the overset boundary condition, while the square cylinder will have a zeroGradient condition: ... OVERSET { type overset; } PRISM { type zeroGradient ; } For the pointDisplacement file, the overset patch will use a zeroGradient condition, and the square cylinder will use a calculated condition: ... OVERSET { patchType overset; type zeroGradient; } PRISM { type calculated; value uniform (0 0 0); } Overset mesh solver settings Finally, the solver settings for the simulation are defined in the &lt;Case&gt;/system/fvSchemes file. The configuration should look as follows: ddtSchemes { default backward; } gradSchemes { default cellLimited Gauss linear 1; } divSchemes { default none; div(phi,U) Gauss linearUpwind grad(U); div((nuEff*dev2(T(grad(U))))) Gauss linear; } laplacianSchemes { default Gauss linear limited 1; } interpolationSchemes { default linear; } snGradSchemes { default limited 1; } wallDist { method meshWave; } oversetInterpolation { method inverseDistance; } fluxRequired { default no; pcorr ; p ; } In this setup, particular emphasis is placed on defining the interpolation method. For this tutorial, the inverseDistance method has been selected to ensure accurate data transfer between the background and overset meshes. Running the case Running the overset case is not straight-forward as running any other case. This is because we specified couple of topoSetDict files and one setFieldsDict. As such, here are the steps to run the case: Step 1: Mesh Generation First, generate the meshes for both the background and overset grids by navigating into the corresponding directories and running the fluent3DMeshToFoam utility: cd background/ fluent3DMeshToFoam Background.msh cd ../overset/ fluent3DMeshToFoam Square.msh cd ../background/ Step 2: Merging the Meshes Since overset mesh operates on overlapping grids, the next step is to merge the two meshes. This is done using the mergeMeshes utility, and it should be executed from within the background directory: mergeMeshes . ../overset/ -overwrite After running this command, OpenFOAM will generate 8 patches, as indicated below: patch names: 8(INLET OUTLET TOP BOTTOM SIDE1 SIDE2 PRISM OVERSET) From this point forward, all operations will be conducted within the background directory. Step 3: Defining Regions and Zone IDs At this point, we have a merged mesh containing both the overset and background meshes. The next task is to define the different regions and zoneIDs as previously mentioned. To do this, run the following command: topoSet This will create the two cell sets. Next, define the zoneID. You will need to create a file called zoneID in the &lt;Case&gt;/0/ directory with the following content: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Website: www.openfoam.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 1.0; format ascii; class volScalarField; object zoneID; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dimensions [0 0 0 0 0 0 0]; internalField uniform 0; boundaryField { overset { type overset; value uniform 0; } ".*" { type zeroGradient; } } // ************************************************************************* // Run the following command to assign the zoneID: setFields This step is crucial as it ensures that the overset zones are properly defined. Step 4: Defining the Moving Zone Next, we define the moving zone. This can be done by running another topoSet command, but this time using the topoSetDict_movingZone file. To define the moving zone, use: topoSet -dict system/topoSetDict_movingZone Step 5: Solver Setup At this point, we are almost ready to run the simulation. First, update the controlDict file to specify the writeInterval and endTime for your simulation, as shown below: /*--------------------------------*- C++ -*----------------------------------*\ | ========= | | | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox | | \\ / O peration | Version: v2412 | | \\ / A nd | Web: www.OpenFOAM.com | | \\/ M anipulation | | \*---------------------------------------------------------------------------*/ FoamFile { version 2.0; format ascii; class dictionary; object controlDict; } // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // libs ( "petscFoam" "overset" "fvMotionSolvers" ); application overPimpleDyMFoam;//pimpleFoam; startFrom latestTime;//startTime; startTime 0; stopAt endTime; endTime 2; // 20 Through times deltaT 0.005; writeControl timeStep; writeInterval 10; purgeWrite 0; writeFormat ascii; writePrecision 8; writeCompression on; timeFormat general; timePrecision 8; runTimeModifiable true; // ************************************************************************* // Finally, run the solver with the following command in your terminal: overPimpleDyMFoam Note: If you’re running a 2D case, ensure you specify empty patches for the side boundaries in &lt;Case&gt;/constant/polyMesh/boundary and &lt;Case&gt;/0/zoneID. Also, specify the overset boundary type for the overset patch in &lt;Case&gt;/constant/polyMesh/boundary. To animate the mesh motion, you can use the moveDynamicMesh utility.]]></summary></entry><entry><title type="html">Simulating Pure Pitching and Heaving Motions in OpenFOAM</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-50/" rel="alternate" type="text/html" title="Simulating Pure Pitching and Heaving Motions in OpenFOAM"/><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-50</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-50/"><![CDATA[<p>Dynamic mesh techniques in Computational Fluid Dynamics (CFD) are pivotal for capturing fluid-structure interactions and other phenomena involving motion. In OpenFOAM, the prescribed motion method allows users to simulate complex scenarios using deformable meshes while maintaining computational efficiency. This article further explores the prescribed mesh motion technique, with a specific focus on simulating pure pitching and pure heaving motions. By the end of this guide, you’ll gain insights into implementing these motions in OpenFOAM and understanding their impact on flow dynamics.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog8/BlogLogo.gif" width="80%"/> </figure> <p>Simulating dynamic motions such as pitching and heaving is critical in understanding the fluid-structure interactions that arise in various engineering and natural systems. Pure pitching and pure heaving motions, which involve rotational and vertical oscillations respectively, are widely studied in aerodynamics and hydrodynamics to analyze phenomena like lift generation, vortex dynamics, and energy harvesting. These simulations require precise control over mesh movement to accurately capture the interaction between the moving body and the surrounding fluid.</p> <p>In my previous article, I introduced the concept of prescribed mesh motion in OpenFOAM, focusing on its application with deformable meshes. Building upon that foundation, this blog explores how to set up and simulate pure pitching and pure heaving motions using OpenFOAM’s dynamic mesh capabilities. I will cover the configuration of the motion profiles, mesh deformation techniques, and practical tips to ensure stable and accurate results. By the end of this blog, you’ll be equipped to implement these dynamic motions and analyze their impact on flow dynamics in your CFD simulations. As a tutorial case, I will select the flow around a thin-flat plate positioned parallel to the flow. To follow along, download the case setup from <a href="https://github.com/goswami-13/ThinFlatPlate">here</a>.</p> <p>Lets Begin!!!</p> <h1 id="key-concepts-of-setting-up-prescribed-motion">Key Concepts of setting up prescribed motion</h1> <p>Prescribed motion is a dynamic mesh technique in OpenFOAM where the motion of a body or mesh is explicitly defined by the user, rather than being computed as a response to fluid-structure interactions. This approach is ideal for scenarios where the motion is known a priori, such as in studies of pure pitching or pure heaving motions. To enable dynamic mesh motion in OpenFOAM, several key settings must be configured to define how the mesh adapts to the prescribed motion. Specifically, four main changes need to be implemented:</p> <ol> <li>Add a <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code> file in the <code class="language-plaintext highlighter-rouge">Case/constant/</code> directory.</li> <li>Specify motion definitions in boundary conditions, using either the <code class="language-plaintext highlighter-rouge">pointDisplacement</code> or <code class="language-plaintext highlighter-rouge">motionUx</code> file.</li> <li>Adjust boundary conditions in the velocity field to account for the movement of the cylinder.</li> <li>Include <code class="language-plaintext highlighter-rouge">cellDisplacement</code> settings in the <code class="language-plaintext highlighter-rouge">Case/system/fvSolution</code> file.</li> </ol> <p>For a detailed explanation of these configurations, refer to my previous article.</p> <p>In this blog, I will demonstrate how to set up pure pitching and pure heaving motions in OpenFOAM by incorporating these four changes into the simulation case. The motion profiles, which form the core of these setups, will be explicitly defined in the <code class="language-plaintext highlighter-rouge">Case/0/pointDisplacement</code> file.</p> <h1 id="simulating-pure-heaving-motion">Simulating Pure Heaving Motion</h1> <p>Pure heaving motion refers to the vertical oscillation of a body and is commonly used to analyze the behavior of wave energy converters, oscillating wings, or underwater vehicles. This motion is characterized by vertical displacement as a function of time, often described using sinusoidal or other periodic profiles. Before simulating pure heaving motion, ensure the geometry is symmetrical along the heaving axis to avoid unintended flow artifacts. Additionally, create a high-quality mesh with fine resolution near the moving body and in regions of interest, such as areas of expected flow separation or wake formation.</p> <p>The motion profile is defined in the <code class="language-plaintext highlighter-rouge">Case/0/pointDisplacement</code> file. For the body (referred to as PRISM in my case), the pure heaving motion is prescribed using the <code class="language-plaintext highlighter-rouge">oscillatingDisplacement</code> boundary condition. This boundary condition implements a sinusoidal oscillation in the transverse (vertical) direction, represented mathematically as:</p> \[y(t) = A sin(\omega t)\] <p>where, A is the amplitude, $\omega = 2\pi f$ is the angular frequency, and t is the time.</p> <p>For this example, the amplitude (A) is set to <code class="language-plaintext highlighter-rouge">0.28</code>, and the angular frequency (𝜔) is specified as <code class="language-plaintext highlighter-rouge">3.1415</code>, corresponding to a frequency (𝑓) of <code class="language-plaintext highlighter-rouge">0.5</code>. The motion is defined in the <code class="language-plaintext highlighter-rouge">Case/0/pointDisplacement</code> file as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    PRISM
    <span class="o">{</span>	
		    <span class="nb">type            </span>oscillatingDisplacement<span class="p">;</span>
        amplitude       <span class="o">(</span> 0 0.28 0 <span class="o">)</span><span class="p">;</span>
        omega           3.1415<span class="p">;</span>
        value           uniform <span class="o">(</span> 0 0 0 <span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
</code></pre></div></div> <p>Once all other mesh motion setup requirements are fulfilled, use the <code class="language-plaintext highlighter-rouge">moveDynamicMesh</code> utility to simulate the pure heaving motion of the flat plate. To observe and visualize the motion, save your simulation data at regular time intervals.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog8/PureHeavingMesh.gif" width="80%"/> </figure> <p>In this blog, the focus is on simulating the mesh movement itself. Running the full simulation, including the application of boundary conditions and solving the flow field, is straightforward but requires some additional considerations. These aspects will be discussed in a future blog post.</p> <h1 id="simulating-pure-pitching-motion">Simulating Pure Pitching Motion</h1> <p>Pure pitching motion involves the rotational oscillation of a body about a fixed axis and is frequently used to study flow dynamics around airfoils, hydrofoils, or oscillating blades. To simulate this in OpenFOAM, the prescribed motion technique is employed to define the angular displacement as a function of time, typically using a sinusoidal profile. To ensure accurate simulation results, it is essential to align the pitching axis correctly relative to the mesh to avoid unintended distortions or flow anomalies, and use a high-quality mesh with sufficient refinement near areas of expected flow separation, vortex shedding, or other critical regions to capture detailed flow dynamics.</p> <p>Unlike pure heaving motion, where displacement is prescribed, pure pitching motion requires defining the rotation angle. For this, OpenFOAM provides the <code class="language-plaintext highlighter-rouge">angularOscillatingDisplacement</code> boundary condition, which applies a sinusoidal variation to the angular displacement. The motion is mathematically described as:</p> \[\theta(t) = \theta_0 + Asin(\omega t)\] <p>where, A is the amplitude of pitching axis, $\theta_0$ is the initial angle of pitching, $\omega = 2\pi f$ is the angular frequency, and t is the time. I will keep these parameters same as above, and the boundary condition should be set as such,</p> <p>For this case, the amplitude (A) is set to <code class="language-plaintext highlighter-rouge">0.28</code>, the angular frequency (𝜔) is <code class="language-plaintext highlighter-rouge">3.1415</code> (corresponding to a frequency of 0.5), and the initial angle is 0. These parameters are defined in the <code class="language-plaintext highlighter-rouge">Case/0/pointDisplacement</code> file as follows:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    PRISM
    <span class="o">{</span>
        <span class="nb">type            </span>angularOscillatingDisplacement<span class="p">;</span>
        axis		<span class="o">(</span>0 0 1<span class="o">)</span><span class="p">;</span>
        origin		<span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
     	  angle0		0<span class="p">;</span>
        amplitude	0.28<span class="p">;</span>
        omega		3.1415<span class="p">;</span>
        value           uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
</code></pre></div></div> <p>Once the boundary condition and other mesh motion configurations are in place, use the <code class="language-plaintext highlighter-rouge">moveDynamicMesh</code> utility to simulate the pure pitching motion of the flat plate. To effectively visualize the motion, save your data at regular time intervals during the simulation.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog8/PurePitchingMesh.gif" width="80%"/> </figure> <h1 id="challenges-and-best-practices">Challenges and Best Practices</h1> <h2 id="challenges">Challenges:</h2> <ol> <li><strong>Mesh Distortion:</strong> Dynamic mesh simulations involve continuous deformation of the computational mesh. Over time, excessive distortion can lead to poor cell quality, such as high skewness or non-orthogonality. This compromises the accuracy of the solution and may cause simulation divergence. For motions with large amplitudes or high frequencies, managing mesh quality becomes particularly challenging.</li> <li><strong>Numerical Instabilities:</strong> Rapid or abrupt motions can lead to unsteady flow phenomena that challenge solver stability. High-frequency oscillations or sharp transitions in motion profiles may result in pressure-velocity coupling issues, leading to non-convergence of the solution.</li> <li><strong>Boundary Condition Mismatches:</strong> Defining boundary conditions that align with the motion can be tricky. For example, inflow and outflow boundaries may not adapt well to rapid oscillations, resulting in unphysical reflections or instabilities near the boundaries.</li> <li><strong>Computational Cost:</strong> Simulations involving dynamic meshes are inherently computationally expensive. Frequent mesh updates increase the computational overhead, especially for fine meshes or complex geometries. Ensuring stability might require smaller time steps, further increasing the cost.</li> <li><strong>Motion Parameter Tuning:</strong> Improperly defined motion parameters (e.g., unrealistic amplitudes, frequencies, or directions) can lead to non-physical behavior, exaggerated mesh distortion, or missed physical phenomena.</li> </ol> <h2 id="best-practices">Best Practices:</h2> <ol> <li><strong>Ensure High-Quality Mesh:</strong> Start with a well-refined mesh, particularly around regions of expected high gradients like the moving body’s boundary layer or wake region. Use tools like checkMesh in OpenFOAM to monitor quality metrics (e.g., skewness, aspect ratio) before and during the simulation. Consider using layered meshes near the moving body to reduce excessive cell deformation.</li> <li><strong>Optimize Motion Parameters:</strong> Define motion profiles (e.g., sinusoidal pitching or heaving) based on realistic physical parameters like Reynolds number, amplitude, and frequency. Gradually increase the motion amplitude or frequency in a controlled manner if instabilities arise.</li> <li><strong>Refine Time Steps and Solvers:</strong> Use a smaller time step (<code class="language-plaintext highlighter-rouge">deltaT</code>) to handle high-frequency motions or rapid mesh deformation. Employ the Courant number (<code class="language-plaintext highlighter-rouge">Co</code>) as a guide to ensure numerical stability. Solvers like PIMPLE or PISO are well-suited for transient dynamic simulations. Adjust under-relaxation factors if needed.</li> <li><strong>Monitor Mesh Quality:</strong> Use OpenFOAM’s built-in mesh motion diagnostics to track mesh distortion during simulations. Enable options like mesh smoothing or layering in the <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code> to mitigate excessive deformation.</li> <li><strong>Use Appropriate Boundary Conditions:</strong> For oscillatory motions, ensure inflow and outflow boundaries can accommodate changes, such as by using wave-transmissive or zero-gradient conditions. Avoid fixed-value conditions that could conflict with the mesh motion.</li> </ol>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[Dynamic mesh techniques in Computational Fluid Dynamics (CFD) are pivotal for capturing fluid-structure interactions and other phenomena involving motion. In OpenFOAM, the prescribed motion method allows users to simulate complex scenarios using deformable meshes while maintaining computational efficiency. This article further explores the prescribed mesh motion technique, with a specific focus on simulating pure pitching and pure heaving motions. By the end of this guide, you’ll gain insights into implementing these motions in OpenFOAM and understanding their impact on flow dynamics.]]></summary></entry><entry><title type="html">Dynamic Meshes in OpenFOAM: A Deep Dive into Prescribed Mesh Motion</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-49/" rel="alternate" type="text/html" title="Dynamic Meshes in OpenFOAM: A Deep Dive into Prescribed Mesh Motion"/><published>2025-03-16T00:00:00+00:00</published><updated>2025-03-16T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-49</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-49/"><![CDATA[<p>Simulating real-world fluid dynamics problems often requires the ability to handle dynamic changes in the computational domain. OpenFOAM’s dynamic mesh capabilities provide the necessary tools for this purpose. This blog explores the fascinating concept of dynamic mesh motion in OpenFOAM, specifically the mesh deformation method using prescribed motion technique. I will showcase the case setup and provide a general overview of simulating mesh motion in OpenFOAM.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog7/BlogLogo.gif" width="80%"/> </figure> <p>Simulating real-world fluid dynamics often requires accounting for moving boundaries, deformable structures, or objects in motion. These scenarios introduce significant challenges in numerical modeling, especially in maintaining the accuracy and stability of simulations. OpenFOAM addresses these challenges with its dynamic mesh capabilities. Dynamic meshes allow for the computational grid to evolve over time, adapting to changes in geometry or boundary motion. Among the various techniques available, the <strong>prescribed mesh motion</strong> method offers a robust way to model scenarios where the motion is predetermined, such as the periodic oscillation of a valve, the movement of a robotic arm, or the deformation of a piston. This approach enables precise control over mesh deformation, ensuring that the computational domain accurately represents the physical system at every timestep.</p> <p>In this blog, I will explore dynamic mesh motion with a focus on the prescribed mesh motion method. This approach is particularly useful when the motion of an object or boundary is predefined. To illustrate this, we will use the example of flow around a square cylinder at a Reynolds number of 100, where the cylinder is subjected to prescribed motion. Through this practical case study, we aim to demystify dynamic mesh motion and equip you with the tools to implement it in OpenFOAM simulations. To follow along, download the case setup from <a href="https://github.com/goswami-13/SquareCylinderRe100">here</a>.</p> <p>Lets Begin!!!</p> <h1 id="understanding-dynamic-mesh-motion">Understanding Dynamic Mesh Motion</h1> <p>Dynamic mesh motion refers to the ability of the computational mesh to adapt and move in response to changes in boundary positions or object movements. This capability is essential for accurately capturing the interaction between fluid flow and moving geometries.</p> <p>In OpenFOAM, dynamic mesh motion can be categorized into several methods, including:</p> <ol> <li><strong>Prescribed Motion:</strong> The motion is explicitly defined by the user, such as a sine wave or a linear translation.</li> <li><strong>Solver-Based Motion:</strong> The motion is determined by solving a set of equations, typically for fluid-structure interaction (FSI) problems.</li> <li><strong>Mesh Topology Changes:</strong> This involves adding or removing cells during the simulation, commonly used in overset or sliding meshes.</li> </ol> <p>This blog focuses on the prescribed motion method, where the motion is user-defined and implemented using the <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code>. This method is computationally efficient and straightforward to use for scenarios where the motion pattern is known a priori. For this I will use the flow around a square cylinder as the base case. The flow around a square cylinder is a classic CFD problem often used to study vortex shedding phenomena and wake dynamics. At a Reynolds number of 100, the flow is laminar, and the cylinder exhibits periodic vortex shedding in its wake. By introducing prescribed motion to the cylinder, we add complexity to the simulation, making it an excellent case for demonstrating dynamic mesh capabilities.</p> <p>The cylinder’s motion is prescribed as a sinusoidal oscillation in the transverse direction, defined by the equation:</p> \[y(t) = A sin(\omega t)\] <p>where, A is the amplitude, $\omega = 2\pi f$ is the angular frequency, and t is the time.</p> <p>To accurately capture the interaction between the oscillating cylinder and the surrounding fluid, the mesh must deform dynamically while maintaining high quality. Using the prescribed motion method in OpenFOAM, we can define the cylinder’s oscillation and simulate the flow field with precision.</p> <h1 id="dynamic-mesh-configuration-in-openfoam">Dynamic Mesh Configuration in OpenFOAM</h1> <p>To enable dynamic mesh motion in OpenFOAM, specific settings must be configured to govern how the mesh adapts to the prescribed motion of the cylinder. This process involves modifying several files in the case directory to define the motion and ensure consistency across the setup. In total, the following four changes are required:</p> <ol> <li>Add a <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code> file in the <code class="language-plaintext highlighter-rouge">Case/constant/</code> directory to define the dynamic mesh solver and motion type.</li> <li>Specify motion definitions in boundary conditions, using either the <code class="language-plaintext highlighter-rouge">pointDisplacement</code> or <code class="language-plaintext highlighter-rouge">motionUx</code> file, depending on the motion type.</li> <li>Adjust boundary conditions in the velocity field to account for the movement of the cylinder.</li> <li>Include <code class="language-plaintext highlighter-rouge">cellDisplacement</code> settings in the <code class="language-plaintext highlighter-rouge">Case/system/fvSolution</code> file to solve the mesh motion equation.</li> </ol> <p>Let’s go through each of these changes step-by-step.</p> <h2 id="defining-the-motion-solver">Defining the Motion Solver</h2> <p>To configure the motion solver, the <code class="language-plaintext highlighter-rouge">Case/constant/dynamicMeshDict</code> file is modified to specify the dynamic mesh settings. Below is an example configuration:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //

dynamicFvMesh      dynamicMotionSolverFvMesh<span class="p">;</span>

motionSolverLibs <span class="o">(</span><span class="s2">"libfvMotionSolvers.so"</span><span class="o">)</span><span class="p">;</span>

motionSolver            displacementLaplacian<span class="p">;</span>

displacementLaplacianCoeffs 
<span class="o">{</span>
    diffusivity         inverseDistance	<span class="o">(</span>PRISM<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">dynamicFvMesh</code> specifies the type of dynamic mesh to use. <code class="language-plaintext highlighter-rouge">dynamicMotionSolverFvMesh</code> indicates that a motion solver will be used to compute the mesh deformation. For the <code class="language-plaintext highlighter-rouge">motionSolver</code>, <code class="language-plaintext highlighter-rouge">displacementLaplacian</code> solver is selected, which calculates mesh motion by solving a Laplace equation for point displacements or velocities. Under the <code class="language-plaintext highlighter-rouge">displacementLaplacianCoeffs</code>, <code class="language-plaintext highlighter-rouge">diffusivity</code> determines how mesh motion is distributed. The <code class="language-plaintext highlighter-rouge">inverseDistance</code> option ensures smoother deformation near the moving boundary. The diffusivity model (<code class="language-plaintext highlighter-rouge">inverseDistance</code>) ensures that mesh deformation diminishes with increasing distance from the moving boundary, minimizing distortion in the outer regions of the mesh. If the displacement-based method is chosen (<code class="language-plaintext highlighter-rouge">displacementLaplacian</code>), a <code class="language-plaintext highlighter-rouge">pointDisplacement</code> boundary condition must be set up to prescribe motion on relevant boundaries.</p> <h2 id="specifying-the-motion">Specifying the Motion</h2> <p>The motion of the mesh is defined in the <code class="language-plaintext highlighter-rouge">pointDisplacement</code> file within the <code class="language-plaintext highlighter-rouge">Case/0/</code> directory. This file specifies the boundary conditions for the prescribed motion. Below is the configuration for the oscillating motion of the cylinder:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  PRISM
  <span class="o">{</span>
      <span class="nb">type            </span>oscillatingDisplacement<span class="p">;</span>
      amplitude       <span class="o">(</span> 0 0.05 0 <span class="o">)</span><span class="p">;</span>
      omega           6.28318<span class="p">;</span>
      value           uniform <span class="o">(</span> 0 0 0 <span class="o">)</span><span class="p">;</span>
  <span class="o">}</span>
</code></pre></div></div> <p>As noted earlier, the motion we are prescribing is a sinusoidal wave defined by an amplitude and angular frequency. I will chose the <code class="language-plaintext highlighter-rouge">amplitude</code> to be 0.05 in Y direction, and a frequency of 1, making the angular frequency (<code class="language-plaintext highlighter-rouge">omega</code>) to be $2\pi$.</p> <p>The remaining parts of the domain, which are stationary, should be assigned a <code class="language-plaintext highlighter-rouge">fixedValue</code> boundary condition. This ensures no motion occurs in these regions.</p> <p>Below is an example configuration for the non-moving boundaries:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span><span class="nt">--------------------------------</span><span class="k">*</span>- C++ -<span class="k">*</span><span class="nt">----------------------------------</span><span class="k">*</span><span class="se">\</span>
| <span class="o">=========</span>                 |                                                 |
| <span class="se">\\</span>      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  <span class="se">\\</span>    /   O peration     | Version:  v2312                                 |
|   <span class="se">\\</span>  /    A nd           | Website:  www.openfoam.com                      |
|    <span class="se">\\</span>/     M anipulation  |                                                 |
<span class="se">\*</span><span class="nt">---------------------------------------------------------------------------</span><span class="k">*</span>/
FoamFile
<span class="o">{</span>
    version     2.0<span class="p">;</span>
    format      ascii<span class="p">;</span>
    class       pointVectorField<span class="p">;</span>
    object      pointDisplacement<span class="p">;</span>
<span class="o">}</span>
// <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> //

dimensions      <span class="o">[</span>0 1 0 0 0 0 0]<span class="p">;</span>

internalField   uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>

boundaryField
<span class="o">{</span>
	TOP
    <span class="o">{</span>
        <span class="nb">type            </span>fixedValue<span class="p">;</span>
        value           uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
    BOTTOM
    <span class="o">{</span>
        <span class="nb">type            </span>fixedValue<span class="p">;</span>
        value           uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>

    SIDE1
    <span class="o">{</span>
        <span class="nb">type            </span>empty<span class="p">;</span>
    <span class="o">}</span>
    SIDE2
    <span class="o">{</span>
        <span class="nb">type            </span>empty<span class="p">;</span>
    <span class="o">}</span>

    INLET
    <span class="o">{</span>
        <span class="nb">type            </span>fixedValue<span class="p">;</span>
        value           uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>

    OUTLET
    <span class="o">{</span>      
        <span class="nb">type            </span>fixedValue<span class="p">;</span>
        value           uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>

    PRISM
    <span class="o">{</span>
        <span class="nb">type            </span>oscillatingDisplacement<span class="p">;</span>
        amplitude       <span class="o">(</span> 0 0.05 0 <span class="o">)</span><span class="p">;</span>
        omega           6.28318<span class="p">;</span>
        value           uniform <span class="o">(</span> 0 0 0 <span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
	
<span class="o">}</span>

// <span class="k">*************************************************************************</span> //
</code></pre></div></div> <h2 id="modify-other-boundary-conditions">Modify other boundary conditions</h2> <p>Next, we need to adjust the velocity boundary conditions for the moving cylinder. To account for the motion of the cylinder, the boundary condition for the cylinder’s surface should be set to <code class="language-plaintext highlighter-rouge">movingWallVelocity</code> as shown below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  PRISM
  <span class="o">{</span>
    <span class="nb">type                      </span>movingWallVelocity<span class="p">;</span>
    value                     uniform <span class="o">(</span>0 0 0<span class="o">)</span><span class="p">;</span>
  <span class="o">}</span>
</code></pre></div></div> <p>For other boundaries such as the inlet and outlet, the velocity boundary conditions need to account for the moving mesh. Depending on the scenario, you may use velocity boundary conditions like <code class="language-plaintext highlighter-rouge">inletVelocity</code> or <code class="language-plaintext highlighter-rouge">outletVelocity</code>, as appropriate for the specific problem. To avoid creating unrealistic pressure gradients at the cylinder surface, the pressure boundary condition should be set to <code class="language-plaintext highlighter-rouge">zeroGradient</code> on the cylinder:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   PRISM
  <span class="o">{</span>
      <span class="nb">type            </span>zeroGradient<span class="p">;</span>
  <span class="o">}</span>
</code></pre></div></div> <h2 id="add-mesh-motion-linear-solver">Add mesh motion linear solver</h2> <p>Dynamic meshes can degrade in quality as the simulation progresses, leading to issues such as excessive skewness or non-orthogonality in the mesh. To mitigate these issues, it is essential to configure the linear solver settings and mesh-quality constraints in the <code class="language-plaintext highlighter-rouge">fvSolution</code> file. Below is an example of the required settings to ensure stable mesh motion and maintain mesh quality:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cellDisplacement
    <span class="o">{</span>
        solver          PCG<span class="p">;</span>
        preconditioner  DIC<span class="p">;</span>
        tolerance       1e-08<span class="p">;</span>
        relTol          0<span class="p">;</span>
		    minIter		3<span class="p">;</span>
    <span class="o">}</span>
	
	  cellDisplacementFinal
    <span class="o">{</span>
        <span class="nv">$cellDisplacement</span><span class="p">;</span>
        relTol          0<span class="p">;</span>
    <span class="o">}</span>
</code></pre></div></div> <h1 id="running-the-simulation">Running the Simulation</h1> <p>After completing the configuration, it’s important to check the quality of the mesh before starting the simulation. You can use the <code class="language-plaintext highlighter-rouge">checkMesh</code> utility to assess the mesh quality and ensure that there are no issues such as skewness, non-orthogonality, or overly deformed cells. Once the mesh passes the check, you can preview the motion of the mesh using the <code class="language-plaintext highlighter-rouge">moveDynamicMesh</code> utility. This allows you to confirm that the mesh deforms correctly before solving the flow equations.</p> <p>To preview the motion without solving for the flow, you can set a small time-step in the <code class="language-plaintext highlighter-rouge">controlDict</code> file, ensuring the time-step adheres to the CFL criterion (for example, a value of 0.4 ensures proper temporal refinement). If needed, you can also run the <code class="language-plaintext highlighter-rouge">moveDynamicMesh</code> utility with a larger time-step to get a quicker preview. Open up your case into an OpenFOAM sourced terminal and type in:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moveDynamicMesh
</code></pre></div></div> <p>The output should look something like this:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Create <span class="nb">time

</span>Create dynamic mesh <span class="k">for </span><span class="nb">time</span> <span class="o">=</span> 0
Selecting dynamicFvMesh dynamicMotionSolverFvMesh
Selecting motion solver: displacementLaplacian
Applying motion to entire mesh
Selecting motion diffusion: inverseDistance
Selecting patchDistMethod meshWave


PIMPLE: Operating solver <span class="k">in </span>PISO mode

Time <span class="o">=</span> 0.0004
PIMPLE: iteration 1
DICPCG:  Solving <span class="k">for </span>cellDisplacementx:  solution singularity
DICPCG:  Solving <span class="k">for </span>cellDisplacementy, Initial residual <span class="o">=</span> 1, Final residual <span class="o">=</span> 4.9321443e-14, No Iterations 3
    Point usage OK.
    Upper triangular ordering OK.
    Topological cell zip-up check OK.
    Face vertices OK.
    Face-face connectivity OK.
    Mesh topology OK.
    Boundary openness <span class="o">(</span><span class="nt">-6</span>.8575785e-18 1.3863136e-17 1.0085072e-15<span class="o">)</span> OK.
    Max cell openness <span class="o">=</span> 2.5540133e-16 OK.
    Max aspect ratio <span class="o">=</span> 100.84633 OK.
    Minimum face area <span class="o">=</span> 9.9295354e-07. Maximum face area <span class="o">=</span> 0.006908216.  Face area magnitudes OK.
    Min volume <span class="o">=</span> 9.9295355e-08. Max volume <span class="o">=</span> 0.00023747556.  Total volume <span class="o">=</span> 0.86300005.  Cell volumes OK.
    Mesh non-orthogonality Max: 1.3579948 average: 0.0780059
    Non-orthogonality check OK.
    Face pyramids OK.
    Max skewness <span class="o">=</span> 0.0064898452 OK.
    Mesh geometry OK.
Mesh OK.
ExecutionTime <span class="o">=</span> 1.56 s  ClockTime <span class="o">=</span> 2 s

...
</code></pre></div></div> <p>You can write out the time directories at regular intervals to visualize the animation of the mesh motion. This helps in confirming the smoothness and accuracy of the mesh deformation as the simulation progresses. To do so, include the following in your <code class="language-plaintext highlighter-rouge">controlDict</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>writeInterval    50<span class="p">;</span>  // Write the data every 50 <span class="nb">time </span>steps
</code></pre></div></div> <p>You can then visualize the results using software like ParaView to create an animation of the mesh motion.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog7/MotionAnim.gif" width="80%"/> </figure> <p>Once you are satisfied with the mesh motion and the preview looks good, you can proceed to run the solver. Use the <code class="language-plaintext highlighter-rouge">pimpleFoam</code> command to simulate the flow around the moving cylinder. This will solve the flow field while accounting for the dynamic motion of the mesh.</p> <h1 id="challenges-and-best-practices">Challenges and Best Practices</h1> <p>Challenges:</p> <ol> <li><strong>Mesh Quality Maintenance:</strong> Dynamic meshes can lead to highly skewed or non-orthogonal cells, affecting solution accuracy and stability. Excessive deformation may result in solver divergence.</li> <li><strong>Computational Cost:</strong> Deforming meshes increase computational overhead, particularly for complex motions or high-resolution grids.</li> <li><strong>Boundary Condition Complexity:</strong> Defining accurate boundary conditions for moving boundaries can be challenging, especially for coupled systems.</li> </ol> <p>Best Practices:</p> <ol> <li><strong>Pre-Simulation Checks:</strong> Use <code class="language-plaintext highlighter-rouge">checkMesh</code> and <code class="language-plaintext highlighter-rouge">moveDynamicMesh</code> to verify the mesh quality and motion before running the simulation. Start with a coarse mesh to debug motion and refine later for accuracy.</li> <li><strong>Mesh Quality Controls:</strong> Set strict mesh quality criteria in the <code class="language-plaintext highlighter-rouge">fvSolution</code> file to avoid excessive skewness or stretching. Regularly monitor mesh quality during the simulation.</li> <li><strong>Solver Selection and Settings:</strong> Choose solvers like <code class="language-plaintext highlighter-rouge">pimpleFoam</code> with relaxation factors to improve stability for dynamic simulations. Use adaptive timesteps to maintain an appropriate Courant number.</li> </ol>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[Simulating real-world fluid dynamics problems often requires the ability to handle dynamic changes in the computational domain. OpenFOAM’s dynamic mesh capabilities provide the necessary tools for this purpose. This blog explores the fascinating concept of dynamic mesh motion in OpenFOAM, specifically the mesh deformation method using prescribed motion technique. I will showcase the case setup and provide a general overview of simulating mesh motion in OpenFOAM.]]></summary></entry><entry><title type="html">Meshes in Motion: Making OpenFOAM Go with the Flow</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-48/" rel="alternate" type="text/html" title="Meshes in Motion: Making OpenFOAM Go with the Flow"/><published>2025-03-02T00:00:00+00:00</published><updated>2025-03-02T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-48</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/03/blog-post-48/"><![CDATA[<p>Simulating flows with moving boundaries and deforming geometries requires specialized computational techniques, and OpenFOAM offers robust tools to tackle such challenges. Dynamic meshes enable mesh motion and deformation, allowing simulations to accurately capture phenomena like valve operations, moving pistons, or deforming structures. In this blog, we will explore the foundational concepts of dynamic meshes in OpenFOAM, covering the principles of mesh motion and their application in CFD. Whether you are a beginner or looking to deepen your understanding, this article sets the stage for harnessing OpenFOAM’s dynamic meshing capabilities.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog6/BlogLogo.gif" width="80%"/> </figure> <p>In Computational Fluid Dynamics (CFD), dealing with moving boundaries, deforming geometries, or interacting objects can feel like solving a dynamic puzzle. OpenFOAM offers an elegant solution: <strong>dynamic meshes</strong>. These meshes allow for the simulation of flows involving motion—be it a piston in an engine, a flapping wing, or even fluid-structure interactions. By enabling the computational grid to move or deform alongside physical boundaries, dynamic meshes bring a new level of realism and precision to CFD simulations. In this blog, we’ll discuss the basics of dynamic meshes and mesh motion in OpenFOAM, setting the stage for tackling complex motion-driven problems in your simulations.</p> <p>Lets begin!!!</p> <h1 id="the-need-for-dynamic-meshes">The Need for Dynamic Meshes</h1> <figure> <img src="https://goswami-13.github.io/images/2025/Blog6/Motion1.png" width="80%"/> </figure> <p>Image Reference <a href="https://doi.org/10.1017/CBO9781139583916">here</a>.</p> <p>Static meshes are the backbone of many CFD simulations, but they have limitations when it comes to modeling motion. Imagine trying to simulate a piston’s movement in an engine, the rotation of a wind turbine blade, or the flapping of a bird’s wing with a fixed mesh. In such cases, the inability of the mesh to adapt to changing boundaries leads to inaccuracies or even simulation failures. Dynamic meshes bridge this gap by allowing the computational grid to move or deform in tandem with the geometry. This flexibility ensures accurate representation of the physics at play, even in scenarios involving large-scale motion or complex interactions. Without dynamic meshes, critical applications like valve operations, ship hydrodynamics, or fluid-structure interactions would remain computationally prohibitive or imprecise. By enabling the mesh to evolve with the problem, dynamic meshes unlock a new level of realism in CFD simulations, making them an indispensable tool for modern engineering challenges.</p> <h1 id="dynamic-meshes-in-openfoam">Dynamic Meshes in OpenFOAM</h1> <figure> <img src="https://goswami-13.github.io/images/2025/Blog6/Motion2.gif" width="80%"/> </figure> <p>Image Reference <a href="https://www.wolfdynamics.com/index.php">here</a>.</p> <p>OpenFOAM’s dynamic mesh framework is a versatile tool designed to handle simulations where the computational domain evolves over time. By allowing the mesh to move, deform, or even change its topology, OpenFOAM ensures accurate representation of physical phenomena involving motion. Whether it’s a rotating wind turbine, an oscillating valve, or fluid-structure interactions, dynamic meshes empower users to model these scenarios with remarkable precision.</p> <p>At the heart of this capability lies the <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code> configuration, where users define how the mesh should behave. OpenFOAM offers various approaches to dynamic meshing, including prescribed motion (like simple translation or rotation), solver-driven motion (governed by physical forces), and more complex techniques like overset meshes or adaptive layering. Each method is tailored to specific types of motion, giving users the flexibility to choose what best suits their simulation needs. Dynamic meshes integrate seamlessly with specialized solvers such as <code class="language-plaintext highlighter-rouge">pimpleDyMFoam</code> and <code class="language-plaintext highlighter-rouge">icoDyMFoam</code>, enabling simulations that capture both mesh motion and fluid dynamics. With its robust implementation, OpenFOAM provides a powerful platform for tackling real-world engineering problems involving moving boundaries and deforming geometries.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog6/Motion3.gif" width="80%"/> </figure> <p>Image Reference <a href="https://www.wolfdynamics.com/index.php">here</a>.</p> <p>Dynamic meshes in OpenFOAM can handle a wide range of motions and deformations, making them highly adaptable for various applications. These motions are categorized based on how the mesh evolves during the simulation. Here’s a brief overview of the most commonly used types of mesh motion:</p> <h2 id="prescribed-motion">Prescribed Motion:</h2> <ul> <li>The motion is predefined and independent of the simulation’s physics.</li> <li>Examples include translating or rotating bodies, such as pistons or propellers.</li> <li>Motion is described using mathematical functions or motion dictionaries (e.g., <code class="language-plaintext highlighter-rouge">solidBodyMotion</code> solvers).</li> </ul> <h2 id="solver-driven-motion">Solver-Driven Motion:</h2> <ul> <li>Here, the mesh motion is governed by physical forces or interactions with the fluid flow.</li> <li>Common in fluid-structure interaction (FSI) problems where structural deformation impacts the fluid domain.</li> <li>Often implemented using solvers like <code class="language-plaintext highlighter-rouge">fvMotionSolver</code>.</li> </ul> <h2 id="arbitrary-mesh-interface-ami">Arbitrary Mesh Interface (AMI):</h2> <ul> <li>Used when different regions of the mesh need to slide or rotate relative to one another.</li> <li>AMI is perfect for applications like rotating machinery or turbochargers.</li> </ul> <h2 id="layer-addition-and-removal">Layer Addition and Removal:</h2> <ul> <li>This technique modifies the mesh topology by adding or removing cell layers to accommodate large displacements.</li> <li>Widely used in applications like piston-cylinder simulations.</li> </ul> <h2 id="overset-meshes-chimera-grid">Overset Meshes (Chimera Grid):</h2> <ul> <li>Combines a background mesh with overlapping movable grids.</li> <li>Suitable for cases like multiple interacting objects (e.g., aircraft in formation).</li> </ul> <h2 id="deforming-meshes">Deforming Meshes:</h2> <ul> <li>The mesh adapts to deformation in the geometry, commonly achieved using displacement equations like Laplace smoothing.</li> <li>Ideal for problems involving small to moderate structural changes.</li> </ul> <h1 id="core-components-of-a-dynamic-mesh-setup">Core Components of a Dynamic Mesh Setup</h1> <p>Setting up a dynamic mesh in OpenFOAM revolves around configuring key files and parameters that dictate how the mesh evolves during the simulation. At the center of this configuration is the <code class="language-plaintext highlighter-rouge">dynamicMeshDict</code>, a dictionary file where users define the motion model, associated parameters, and boundary conditions for the mesh. This file specifies how the mesh should behave—whether it should translate, rotate, deform, or adapt to the motion of the geometry. Selecting the appropriate motion solver here is crucial, as it determines how the mesh adapts to the problem’s requirements.</p> <p>Another critical aspect is the interaction between the mesh motion and the solver. OpenFOAM provides solvers like <code class="language-plaintext highlighter-rouge">pimpleDyMFoam</code> and <code class="language-plaintext highlighter-rouge">icoDyMFoam</code>, which are designed to handle dynamic meshes while solving the fluid flow equations. These solvers ensure that the mesh deformation or movement is accounted for in the numerical calculations, maintaining accuracy in capturing the physics. Integrating mesh motion seamlessly with fluid dynamics requires careful attention to time-stepping and mesh quality to avoid numerical instability.</p> <p>Boundary conditions for dynamic meshes are just as important. For example, specifying fixed or moving boundaries, applying constraints, or allowing free motion at specific faces of the mesh are all defined in the case setup. Common types include <code class="language-plaintext highlighter-rouge">movingWall</code>, <code class="language-plaintext highlighter-rouge">slip</code>, and custom boundary conditions for rotating or deforming walls. This ensures that the mesh behaves appropriately at the interfaces and boundaries, accurately reflecting the physical motion of the system.</p> <p>Finally, mesh quality plays a vital role in the success of a dynamic mesh simulation. As the mesh moves or deforms, ensuring that cells remain well-shaped and properly resolved is essential to avoid errors or inaccuracies. Tools within OpenFOAM, such as mesh smoothing or cell layering, help maintain mesh quality during the simulation. By understanding and configuring these core components, users can unlock the full potential of dynamic meshes for complex CFD applications.</p> <h1 id="a-look-ahead">A Look Ahead</h1> <p>While this blog covered the basics of dynamic meshes in OpenFOAM, the world of mesh motion and deformation offers a wealth of advanced techniques and possibilities. Moving forward, I will explore more sophisticated topics that build on the foundation laid here. These include:</p> <ol> <li><strong>Prescribed Motion :</strong> These tutorials are excellent starting points to understand how to set up simple motion scenarios and apply predefined motions to objects like fans, blades, or pistons. By diving into these tutorials, you’ll get hands-on experience with the <code class="language-plaintext highlighter-rouge">solidBodyMotionSolver</code> and related boundary conditions, which are the foundation for many dynamic simulations.</li> <li><strong>Overset Mesh :</strong> Overset meshes, also known as Chimera grids, are a powerful technique for simulating multiple moving objects within a fluid flow. OpenFOAM supports overset meshes, which allow for the overlapping of meshes that move independently of each other. These meshes are particularly useful in complex simulations such as aircraft maneuvers or moving vehicles in a dynamic environment. These tutorials on overset meshes will guide you through the process of setting up multiple grids, managing mesh interfaces, and solving complex interactions between moving bodies.</li> <li><strong>Adaptive Mesh Refinement (AMR):</strong> Adaptive Mesh Refinement (AMR) is a technique used to improve mesh resolution in regions of interest while maintaining computational efficiency. This is especially useful when simulating dynamic flows with sharp gradients or localized phenomena like turbulence or shock waves. AMR enables OpenFOAM to refine the mesh dynamically during the simulation, focusing resources where they are needed most. Tutorials on AMR will teach you how to implement adaptive mesh strategies and balance refinement levels with simulation performance.</li> <li><strong>Fluid-Structure Interaction (FSI):</strong> Fluid-Structure Interaction (FSI) is a complex simulation method that deals with the interaction between fluids and deformable solids. OpenFOAM integrates FSI through solvers like <code class="language-plaintext highlighter-rouge">solidDisplacementFoam</code> and coupling with external solvers such as <code class="language-plaintext highlighter-rouge">solids4Foam</code> and <code class="language-plaintext highlighter-rouge">preCICE</code>. Tutorials on FSI in OpenFOAM will help you simulate cases where fluid forces cause structural deformation, like in wind turbines, flexible membranes, or vessels under pressure. Learning FSI will allow you to explore the dynamics of both fluid and structural systems together, expanding your simulation toolkit significantly.</li> </ol> <p>By diving into these advanced topics, we’ll unlock even more powerful simulation capabilities in OpenFOAM, enabling you to tackle a wider range of engineering problems involving dynamic meshes, motion, and complex interactions.</p>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Moving Meshes"/><category term="Tutorial"/><summary type="html"><![CDATA[Simulating flows with moving boundaries and deforming geometries requires specialized computational techniques, and OpenFOAM offers robust tools to tackle such challenges. Dynamic meshes enable mesh motion and deformation, allowing simulations to accurately capture phenomena like valve operations, moving pistons, or deforming structures. In this blog, we will explore the foundational concepts of dynamic meshes in OpenFOAM, covering the principles of mesh motion and their application in CFD. Whether you are a beginner or looking to deepen your understanding, this article sets the stage for harnessing OpenFOAM’s dynamic meshing capabilities.]]></summary></entry><entry><title type="html">3D DMD and Visualization with OpenFOAM and Python</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/02/blog-post-47/" rel="alternate" type="text/html" title="3D DMD and Visualization with OpenFOAM and Python"/><published>2025-02-16T00:00:00+00:00</published><updated>2025-02-16T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/02/blog-post-47</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/02/blog-post-47/"><![CDATA[<p>Understanding the complex, dynamic behavior of fluid flows often requires more than just time-averaged statistics. Dynamic Mode Decomposition (DMD) offers a powerful, data-driven approach to uncover the temporal evolution of coherent structures within CFD datasets. In this blog, we’ll dive into the process of applying DMD to three-dimensional flow fields simulated using OpenFOAM and visualize the resulting modes with Python and ParaView. By combining these tools, we can unravel the intricate interactions that define unsteady flows, providing insights into both dominant patterns and transient dynamics.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog5_2025/BlogLogo.gif" width="80%"/> </figure> <p>Understanding the complex dynamics of unsteady fluid flows requires tools that go beyond traditional averaging techniques. In my previous article on 3D Proper Orthogonal Decomposition (POD), we explored how to identify the dominant spatial structures in a flow field using OpenFOAM data. While POD is invaluable for spatial decomposition, it lacks the ability to capture temporal evolution—a crucial aspect when studying unsteady or transient phenomena.</p> <p>This is where Dynamic Mode Decomposition (DMD) shines. DMD bridges the gap by uncovering modes that represent both spatial patterns and their associated temporal behavior. In this blog, we’ll build on the groundwork laid in <a href="https://medium.com/gitconnected/3d-pod-and-visualization-with-openfoam-and-python-d84c177b9119">my 3D POD article</a> and demonstrate how to apply DMD to three-dimensional flow data. Using OpenFOAM for simulations, Python for data handling, and ParaView for visualization, we’ll uncover the temporal dynamics of a classic fluid flow problem. By the end of this tutorial, you’ll see how DMD complements POD, enabling a deeper understanding of unsteady flows.</p> <p>In this tutorial, I’ll once again explore the dynamics of three-dimensional flow around a square cylinder at a Reynolds number of 260. For your convenience, a reference case setup is available <a href="https://github.com/goswami-13/3D_SquareCylinder.git">here</a>.</p> <p>Lets Begin!!</p> <h1 id="3d-dynamic-mode-decomposition">3D Dynamic Mode Decomposition</h1> <p>Building on the foundations from the previous article, we’ll use the pre-assembled snapshot matrix, <code class="language-plaintext highlighter-rouge">data_Vort</code>, along with the <a href="https://modulo.readthedocs.io/en/latest/intro.html">MODULO</a> package to perform 3D Dynamic Mode Decomposition (DMD). This step-by-step guide will demonstrate how to set up the necessary environment, process the data, and extract meaningful temporal dynamics.</p> <p>We’ll start by loading the required Python modules and defining the necessary path variables in a Jupyter Notebook:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.colors</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">fluidfoam</span> <span class="k">as</span> <span class="n">fl</span> <span class="c1">### Most Important
</span><span class="kn">import</span> <span class="n">scipy</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">from</span> <span class="n">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">io</span>
<span class="kn">import</span> <span class="n">pyvista</span> <span class="k">as</span> <span class="n">pv</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span> <span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="sh">'</span><span class="s">font.family</span><span class="sh">'</span> <span class="p">:</span> <span class="sh">'</span><span class="s">Times New Roman</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">text.usetex</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>

<span class="c1"># Path variables
</span><span class="n">Path</span> <span class="o">=</span> <span class="sh">'</span><span class="s">E:/Blog_Posts/Simulations/3D_Bai/</span><span class="sh">'</span>

<span class="c1"># Constants
</span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Ub</span> <span class="o">=</span> <span class="mf">0.039</span>
</code></pre></div></div> <p>Next, import the <code class="language-plaintext highlighter-rouge">data_Vort</code> matrix, which contains the 3D snapshots of the vorticity field, and check its dimensions:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import matrix
</span><span class="n">data_Vort</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">Path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">VortZ.npy</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Check matrix shape
</span><span class="n">data_Vort</span><span class="p">.</span><span class="n">shape</span>
<span class="c1">### OUTPUT
### (624537, 161)
</span></code></pre></div></div> <p>This output confirms that the dataset consists of a 3D spatial mesh with 624,537 elements and 161 temporal snapshots.</p> <p>To proceed with the DMD analysis, we’ll initialize the MODULO package:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">modulo_vki</span> <span class="kn">import</span> <span class="n">ModuloVKI</span>

<span class="c1"># Initialize MODULO object
</span><span class="n">m</span> <span class="o">=</span> <span class="nc">ModuloVKI</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">nan_to_num</span><span class="p">(</span><span class="n">data_Vort</span><span class="p">),</span> <span class="n">n_Modes</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
</code></pre></div></div> <p>DMD requires the sampling frequency of the dataset, which corresponds to the time interval between consecutive snapshots in the simulation. Retrieve this information from the OpenFOAM simulation setup:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Sampling time and frequency
</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">*</span><span class="mi">25</span>
<span class="n">F_S</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span>
</code></pre></div></div> <p>Finally, compute the DMD modes, eigenvalues, frequencies, and initial amplitudes using the MODULO package:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Compute DMD using MODULO
</span><span class="n">Phi_D</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">a0s</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">compute_DMD_PIP</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">F_S</span><span class="o">=</span><span class="n">F_S</span><span class="p">)</span>
</code></pre></div></div> <p>With these steps, we’ve successfully performed DMD on the 3D dataset. The resulting outputs will allow us to explore the temporal evolution of coherent flow structures.</p> <p>After computing the DMD, a crucial step is to analyze the <strong>DMD circle</strong>, which provides insight into the dynamic behavior of the flow. The eigenvalues obtained from the DMD computation form a set of complex numbers, each carrying distinct significance regarding the behavior of their corresponding dynamic modes:</p> <ol> <li><strong>Oscillation:</strong> A non-zero imaginary part indicates oscillation in the dynamic mode.</li> <li><strong>Decay:</strong> If the eigenvalue lies inside the unit circle, the dynamic mode decays over time.</li> <li><strong>Growth:</strong> Eigenvalues outside the unit circle signify growing dynamic modes.</li> <li><strong>Neutral Stability:</strong> Eigenvalues on the unit circle correspond to modes that neither grow nor decay, indicating stability.</li> </ol> <p>This understanding enables us to plot a unit circle and overlay the scatter plot of real versus imaginary parts of the eigenvalues to visualize their behavior. Below is the Python implementation for constructing the DMD circle:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#%% Plot DMD Spectra in the Circle
</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">()</span> 
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">imag</span><span class="p">(</span><span class="n">Lambda</span><span class="p">),</span><span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Lambda</span><span class="p">),</span><span class="sh">'</span><span class="s">ko</span><span class="sh">'</span><span class="p">)</span>
<span class="n">circle</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="nc">Circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$\Lambda_r$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$\Lambda_i$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD_Circle.jpeg" width="80%"/> </figure> <p>In this plot, all eigenvalues lie on the unit circle, indicating that the corresponding DMD modes are neutrally stable. These modes neither grow nor decay, making them ideal for studying steady oscillatory phenomena in the flow. This stability is particularly significant when analyzing flows where sustained oscillations dominate, such as vortex shedding in bluff-body wakes.</p> <h1 id="3d-dmd-visualization">3D DMD Visualization</h1> <p>To visualize the 3D structures of DMD modes, we’ll leverage Python and ParaView. However, before diving into the visualization, it’s crucial to gain an understanding of the <strong>temporal dynamics</strong> of the flow using a simple Fast Fourier Transform (FFT). Unlike POD, DMD extracts both spatial and temporal structures, with each mode being associated with a specific frequency.</p> <p>Given the complexity of a highly three-dimensional flow like ours, we aim to identify modes corresponding to distinct frequencies that signify key flow phenomena. For instance, in the case of flow around a square cylinder, <strong>periodic vortex shedding</strong> is a prominent feature in the wake. By focusing on the dominant frequency of this shedding and its harmonics, we can extract and analyze DMD modes relevant to these phenomena.</p> <p>To begin, we perform an FFT to analyze the temporal dynamics of the flow:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">### FFT 
</span>
<span class="c1">### Constants
</span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Ub</span> <span class="o">=</span> <span class="mf">0.039</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">*</span><span class="mi">25</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span>

<span class="n">Signal1</span> <span class="o">=</span> <span class="n">data_Vort</span><span class="p">[</span><span class="mi">50000</span><span class="p">,:]</span>

<span class="c1">### PSD using welch
</span><span class="n">f1</span><span class="p">,</span> <span class="n">Eu1</span> <span class="o">=</span> <span class="n">sp</span><span class="p">.</span><span class="n">signal</span><span class="p">.</span><span class="nf">welch</span><span class="p">(</span><span class="n">Signal1</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nfft</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">Signal1</span><span class="p">),</span> <span class="n">nperseg</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">Signal1</span><span class="p">),</span> <span class="n">window</span><span class="o">=</span><span class="sh">'</span><span class="s">hamming</span><span class="sh">'</span><span class="p">)</span>
<span class="n">St1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">()</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">loglog</span><span class="p">(</span><span class="n">St1</span><span class="p">,</span> <span class="n">Eu1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$\bf E_x$</span><span class="sh">'</span><span class="p">))</span>

<span class="n">xmax</span> <span class="o">=</span> <span class="n">St1</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">Eu1</span><span class="o">*</span><span class="n">f1</span><span class="o">/</span><span class="p">(</span><span class="n">Ub</span><span class="o">**</span><span class="mi">2</span><span class="p">))]</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Strouhal Number = </span><span class="sh">"</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="sh">'</span><span class="s">--</span><span class="sh">'</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="nf">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="sh">'</span><span class="s">best</span><span class="sh">'</span><span class="p">,</span> <span class="n">frameon</span> <span class="o">=</span> <span class="bp">False</span><span class="p">);</span> <span class="c1"># or 'best', 'upper right', etc
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$St$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$E_{u_i}$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_tick_params</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="nf">set_ticks_position</span><span class="p">(</span><span class="sh">'</span><span class="s">both</span><span class="sh">'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/2025/Blog5_2025/Power.jpeg" width="80%"/> </figure> <p>Here, we observe a dominant peak in the frequency spectrum corresponding to a Strouhal number of approximately 0.14, indicating the periodic vortex shedding in the wake. This provides a clear target for analysis: we can extract DMD modes corresponding to this frequency and its harmonics, which encapsulate the spatial structures associated with this flow phenomenon.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File location to write a VTK File
</span><span class="n">WhereWrite</span> <span class="o">=</span> <span class="sh">'</span><span class="s">E:/Blog_Posts/Simulations/3D_Bai/postProcessing/</span><span class="sh">'</span>

<span class="c1"># First snapshot, base file
</span><span class="n">WriteFile</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">Surfaces</span> <span class="o">+</span> <span class="n">Files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">/internal.vtu</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Extract Modes
</span><span class="n">DMD_Mode1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">18</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">19</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">30</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode4</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">31</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode5</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">48</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode6</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">49</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode7</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">138</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>
<span class="n">DMD_Mode8</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">real</span><span class="p">(</span><span class="n">Phi_D</span><span class="p">[:,</span><span class="mi">139</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">))</span>

<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode1</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode1</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode2</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode2</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode3</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode3</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode4</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode4</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode5</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode5</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode6</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode6</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode7</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode7</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode8</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">DMD_Mode8</span>

<span class="n">WriteFile</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">WhereWrite</span> <span class="o">+</span> <span class="sh">'</span><span class="s">Visualize_2.vtu</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>Now, let’s open these extracted modes in ParaView to visualize their 3D structures.</p> <p><img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD1.jpeg" width="49%"/><img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD2.jpeg" width="49%"/></p> <p><img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD3.jpeg" width="49%"/><img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD4.jpeg" width="49%"/></p> <p><img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD5.jpeg" width="49%"/><img src="https://goswami-13.github.io/images/2025/Blog5_2025/DMD6.jpeg" width="49%"/></p> <p>These visualizations clearly reveal the 3D flow instabilities present in the dataset. With higher-resolution data, one could delve deeper into the vortex dynamics, observe the formation of ribs and rollers, and explore complex interactions within such flows. This highlights the power of DMD in identifying and isolating key spatio-temporal features.</p> <p>To gain further insights, let’s extract a 2D slice from the dataset and use Python for a more detailed visualization of the flow structures behind the cylinder. Using ParaView, create and save the slice as <code class="language-plaintext highlighter-rouge">Slice2.vtp</code>. Then, load this slice into the Python workflow as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Read Slice
</span><span class="n">Data2D</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">WhereWrite</span> <span class="o">+</span> <span class="sh">'</span><span class="s">Slice2.vtp</span><span class="sh">'</span><span class="p">)</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">points</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">rows = </span><span class="sh">'</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="sh">'</span><span class="s">columns = </span><span class="sh">'</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

<span class="c1"># Extract DMD Modes inforation
</span><span class="n">DMD_Mode0</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode0</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode1</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode1</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode2</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode2</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode3</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode3</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode4</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode4</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode5</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode5</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode6</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode6</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode7</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode7</span><span class="sh">'</span><span class="p">]</span>
<span class="n">DMD_Mode8</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">DMD_Mode8</span><span class="sh">'</span><span class="p">]</span>
</code></pre></div></div> <p>Finally, we can plot the selected modes for a clear visualization of the 2D flow structures:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog5_2025/First6Modes_DMD.jpeg" width="80%"/> </figure> <p>In this article, we explored the application of 3D Dynamic Mode Decomposition (DMD) to unravel the spatio-temporal dynamics of a highly three-dimensional flow. From understanding the DMD spectra and its implications for dynamic behavior to visualizing 3D flow structures in ParaView, we showcased how DMD serves as a powerful tool for uncovering complex flow phenomena. By coupling this technique with Python and OpenFOAM datasets, we demonstrated a workflow that balances computational rigor with visual clarity. The ability to isolate dominant frequencies and corresponding spatial modes opens the door to deeper insights into vortex shedding, instabilities, and flow evolution. As CFD data grows richer and more intricate, tools like DMD will continue to play a pivotal role in bridging numerical simulations with actionable insights.</p>]]></content><author><name></name></author><category term="DataAnalysis"/><category term="Modal Decomposition"/><category term="Python"/><summary type="html"><![CDATA[Understanding the complex, dynamic behavior of fluid flows often requires more than just time-averaged statistics. Dynamic Mode Decomposition (DMD) offers a powerful, data-driven approach to uncover the temporal evolution of coherent structures within CFD datasets. In this blog, we’ll dive into the process of applying DMD to three-dimensional flow fields simulated using OpenFOAM and visualize the resulting modes with Python and ParaView. By combining these tools, we can unravel the intricate interactions that define unsteady flows, providing insights into both dominant patterns and transient dynamics.]]></summary></entry><entry><title type="html">3D POD and Visualization with OpenFOAM and Python</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/02/blog-post-46/" rel="alternate" type="text/html" title="3D POD and Visualization with OpenFOAM and Python"/><published>2025-02-09T00:00:00+00:00</published><updated>2025-02-09T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/02/blog-post-46</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/02/blog-post-46/"><![CDATA[<p>In fluid dynamics, understanding the intricate patterns hidden within three-dimensional flow data is crucial for advancing both research and engineering applications. Proper Orthogonal Decomposition (POD) serves as a powerful tool to extract dominant flow structures, simplifying complex dynamics into comprehensible insights. This article takes you through the step-by-step application of three-dimensional POD using OpenFOAM simulation data and Python wizardry, emphasizing visualization for enhanced interpretation. Whether you’re a CFD enthusiast or a seasoned researcher, this guide will equip you with practical skills to explore and analyze multi-dimensional fluid flows effectively.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/BlogLogo.gif" width="80%"/> </figure> <p>Understanding the spatio-temporal dynamics of fluid flow is a cornerstone of Computational Fluid Dynamics (CFD) analysis. Proper Orthogonal Decomposition (POD) is a widely-used technique for uncovering dominant flow structures in complex datasets, offering a gateway to simplifying and interpreting intricate flow dynamics. In this blog, we dive into the application of 3D POD using OpenFOAM simulation data, processed using Python and visualized with ParaView. By transforming CFD results into insightful visual patterns, this approach enhances our ability to analyze and comprehend multi-dimensional fluid behavior.</p> <p>This article builds upon the methodology discussed in my previous blog - <a href="https://medium.com/gitconnected/extracting-3d-snapshots-from-openfoam-for-modal-decomposition-analysis-72e8877eb7ed">Extracting 3D Snapshots from OpenFOAM for Modal Decomposition Analysis</a>. There, we explored how to gather and preprocess simulation snapshots, a critical first step for modal analysis techniques like POD. Now, we take the next leap, leveraging those extracted snapshots to perform a full 3D POD analysis and create visualizations that bring flow structures to life. If you’ve followed the steps outlined earlier, you’re well-prepared to embark on this deeper dive into flow decomposition and visualization.</p> <p>If you’re new to modal decomposition or OpenFOAM, I recommend checking out my <a href="https://medium.com/stackademic/unveiling-the-secrets-of-flow-a-mathematical-introduction-to-proper-orthogonal-decomposition-4fe5204cca8a">previous articles</a>, which provide a solid foundation in the POD methodology and its underlying mathematical principles.</p> <p>In this tutorial, we’ll once again explore the dynamics of three-dimensional flow around a square cylinder at a Reynolds number of 260. For your convenience, a reference case setup is available <a href="https://github.com/goswami-13/3D_SquareCylinder.git">here</a>.</p> <p>Lets Begin!!!</p> <h1 id="3d-proper-orthogonal-decomposition">3D Proper Orthogonal Decomposition</h1> <p>In my previous article, we explored the process of extracting 3D snapshots from OpenFOAM simulations and preparing the data for modal decomposition analysis. As part of that workflow, we assembled a matrix, <code class="language-plaintext highlighter-rouge">data_Vort</code>, which will serve as the foundation for our POD analysis in this tutorial. Now, let’s dive back in by opening a Jupyter Notebook and importing the necessary modules.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.colors</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">fluidfoam</span> <span class="k">as</span> <span class="n">fl</span> <span class="c1">### Most Important
</span><span class="kn">import</span> <span class="n">scipy</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">from</span> <span class="n">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">io</span>
<span class="kn">import</span> <span class="n">pyvista</span> <span class="k">as</span> <span class="n">pv</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span> <span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="sh">'</span><span class="s">font.family</span><span class="sh">'</span> <span class="p">:</span> <span class="sh">'</span><span class="s">Times New Roman</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">text.usetex</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</code></pre></div></div> <p>Next, we’ll assign the necessary path variables and define the data matrix:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Path variables
</span><span class="n">Path</span> <span class="o">=</span> <span class="sh">'</span><span class="s">E:/Blog_Posts/Simulations/3D_Bai/</span><span class="sh">'</span>

<span class="c1"># Constants
</span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">Ub</span> <span class="o">=</span> <span class="mf">0.039</span>
</code></pre></div></div> <p>At this stage, we’ll import the <code class="language-plaintext highlighter-rouge">data_Vort</code> matrix and verify its shape:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import matrix
</span><span class="n">data_Vort</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">Path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">VortZ.npy</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Check matrix shape
</span><span class="n">data_Vort</span><span class="p">.</span><span class="n">shape</span>
<span class="c1">### OUTPUT
### (624537, 161)
</span></code></pre></div></div> <p>The matrix shape reveals the spatial and temporal degrees of freedom in our dataset. Here, the 3D mesh consists of 624,537 elements with 161 time-varying snapshots for analysis. Understanding the structure of your dataset is crucial for ensuring accurate and efficient modal decomposition!</p> <p>For this tutorial, I will use <a href="https://modulo.readthedocs.io/en/latest/intro.html">MODULO</a>, a cutting-edge software developed at the von Karman Institute for performing advanced data-driven decompositions. While initially designed for Multiscale Proper Orthogonal Decomposition (mPOD), MODULO has evolved to support a wide array of methods, including POD, SPOD, DFT, DMD, and more. Its standout feature is its efficiency: it processes large datasets by dividing them into manageable chunks, making it perfect for high-complexity applications. Furthermore, MODULO excels at handling non-uniform meshes through its weighted inner product approach, ensuring precise results.</p> <p>If you’d like to learn more about MODULO, check out my earlier article <a href="https://levelup.gitconnected.com/data-driven-modal-analysis-with-modulo-and-openfoam-1052dc200114">here</a>.</p> <p>Let’s now import the MODULO package into our notebook:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">modulo_vki</span> <span class="kn">import</span> <span class="n">ModuloVKI</span>
</code></pre></div></div> <p>Next, let’s initialize MODULO:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Initialize MODULO object
</span><span class="n">m</span> <span class="o">=</span> <span class="nc">ModuloVKI</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">nan_to_num</span><span class="p">(</span><span class="n">data_Vort</span><span class="p">),</span> <span class="n">n_Modes</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</code></pre></div></div> <p>This initialization configures the data_Vort matrix to be read into the MODULO POD class, specifying that the first 50 modes will be extracted from the dataset. Using MODULO, we’ll now compute POD with the Singular Value Decomposition (SVD) method, which is particularly well-suited for smaller datasets due to its generality and efficiency.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># POD via svd
</span><span class="n">Phi_P</span><span class="p">,</span> <span class="n">Psi_P</span><span class="p">,</span> <span class="n">Sigma_P</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">compute_POD_svd</span><span class="p">()</span>

<span class="c1"># Check matrix shapes
</span><span class="n">Phi_P</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Psi_P</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Sigma_P</span><span class="p">.</span><span class="n">shape</span>
<span class="c1">### OUTPUT
### ((624537, 50), (161, 50), (50,))
</span></code></pre></div></div> <p>With POD successfully performed, we can now visualize the energy content of each POD mode along with the cumulative energy to gain insights into how energy is distributed across the modes.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Energy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">Sigma_P</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">Sigma_P</span><span class="p">)):</span>
    <span class="n">Energy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sigma_P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">Sigma_P</span><span class="p">)</span>

<span class="n">X_Axis</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">Energy</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">heights</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">Energy</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">,</span> <span class="n">markerfacecolor</span> <span class="o">=</span> <span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">markeredgecolor</span> <span class="o">=</span> <span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Modes</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Energy Content</span><span class="sh">'</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">Sigma_P</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">Sigma_P</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">cumulative</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">,</span> <span class="n">markerfacecolor</span> <span class="o">=</span> <span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">markeredgecolor</span> <span class="o">=</span> <span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Modes</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Cumulative Energy</span><span class="sh">'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/Energy.jpeg" width="80%"/> </figure> <p>This plot illustrates that the first 10 POD modes capture approximately 67% of the total energy, indicating that a significant portion of the flow dynamics can be effectively represented with these modes. By focusing on these dominant modes, we achieve a substantial reduction in the dimensionality of the dataset, which simplifies further analysis and computational modeling. Such dimensionality reduction is especially valuable in scenarios where computational resources are limited or when developing reduced-order models (ROMs) for real-time simulations or control systems. Moreover, these modes often correspond to the most physically meaningful flow structures, allowing researchers to gain deeper insights into the underlying dynamics without being overwhelmed by less significant variations. This balance between accuracy and efficiency makes POD a powerful tool for analyzing complex fluid flows.</p> <h1 id="3d-pod-visualization">3D POD Visualization</h1> <p>To visualize the POD output in 3D, we’ll use a combination of Python and ParaView. Python will be utilized to write the first 10 POD modes into a VTK file, which can then be opened in ParaView for detailed visualization. As a first step, we’ll read in the first snapshot from the simulation to serve as the base VTK file into which our output will be written:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File location to write a VTK File
</span><span class="n">WhereWrite</span> <span class="o">=</span> <span class="sh">'</span><span class="s">E:/Blog_Posts/Simulations/3D_Bai/postProcessing/</span><span class="sh">'</span>

<span class="c1"># First snapshot, base file
</span><span class="n">WriteFile</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">Surfaces</span> <span class="o">+</span> <span class="n">Files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">/internal.vtu</span><span class="sh">'</span><span class="p">)</span>

<span class="n">WriteFile</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/OUTPUT1.png" width="80%"/> </figure> <p>Next, we’ll proceed to write the first 10 POD modes into this file for visualization.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Mode0</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode1</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode2</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode3</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode4</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode5</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode6</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode7</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode8</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">8</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode9</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>
<span class="n">Mode10</span> <span class="o">=</span> <span class="n">Phi_P</span><span class="p">[:,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">Ub</span><span class="p">)</span>

<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode0</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode0</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode1</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode1</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode2</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode2</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode3</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode3</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode4</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode4</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode5</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode5</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode6</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode6</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode7</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode7</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode8</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode8</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode9</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode9</span>
<span class="n">WriteFile</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode10</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mode10</span>

<span class="n">WriteFile</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">WhereWrite</span> <span class="o">+</span> <span class="sh">'</span><span class="s">Visualize_Final.vtu</span><span class="sh">'</span><span class="p">)</span>

<span class="n">WriteFile</span>
</code></pre></div></div> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/OUTPUT2.png" width="80%"/> </figure> <p><em>PS: Don’t worry about the <code class="language-plaintext highlighter-rouge">.vtu</code> extension—it’s simply a VTK file!</em></p> <p>Now, let’s open this VTK file in ParaView. Once loaded, it should look something like this:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/Paraview1.png" width="80%"/> </figure> <p>To visualize the modes, navigate to <strong>Filters -&gt; Common -&gt; Contour</strong>. Specify the appropriate ranges for the iso-surfaces and add a square cylinder representation by selecting <strong>Sources -&gt; Geometric Shapes -&gt; Box</strong>. The first mode should appear as follows:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/MODE1.png" width="80%"/> </figure> <p>Similarly, you can visualize the first six modes:</p> <p><img src="https://goswami-13.github.io/images/2025/Blog4_2025/M1.jpeg" width="49%"/><img src="https://goswami-13.github.io/images/2025/Blog4_2025/M2.jpeg" width="49%"/></p> <p><img src="https://goswami-13.github.io/images/2025/Blog4_2025/M3.jpeg" width="49%"/><img src="https://goswami-13.github.io/images/2025/Blog4_2025/M4.jpeg" width="49%"/></p> <p><img src="https://goswami-13.github.io/images/2025/Blog4_2025/M5.jpeg" width="49%"/><img src="https://goswami-13.github.io/images/2025/Blog4_2025/M6.jpeg" width="49%"/></p> <p>3D visualization provides valuable insights into the spanwise vortex activity within the system. Exploring these 3D instabilities and understanding the three-dimensionality of the flow is crucial for characterizing the dynamics of this configuration.</p> <p>Next, we’ll take a 2D slice of the data to analyze in Python. While ParaView is excellent for visualizing flow structures, Python offers greater control over the output, making it ideal for detailed analysis. To create a slice, use <strong>Filters -&gt; Common -&gt; Slice</strong> and define a 2D slice along the Z-direction:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/Paraview2.png" width="80%"/> </figure> <p>Once the slice is created, save it by selecting <strong>File -&gt; Save Data</strong> and choosing <code class="language-plaintext highlighter-rouge">VTK PolyData File (*.vtp)</code> as the file format.</p> <p>Finally, we’ll read this slice back into our Jupyter Notebook and extract the modes for further analysis:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Read 2D slice
</span><span class="n">Data2D</span> <span class="o">=</span> <span class="n">pv</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">WhereWrite</span> <span class="o">+</span> <span class="sh">'</span><span class="s">Slice1.vtp</span><span class="sh">'</span><span class="p">)</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">points</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

<span class="c1"># Extract Modes
</span><span class="n">Mode1</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode1</span><span class="sh">'</span><span class="p">]</span>
<span class="n">Mode2</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode2</span><span class="sh">'</span><span class="p">]</span>
<span class="n">Mode3</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode3</span><span class="sh">'</span><span class="p">]</span>
<span class="n">Mode4</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode4</span><span class="sh">'</span><span class="p">]</span>
<span class="n">Mode5</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode5</span><span class="sh">'</span><span class="p">]</span>
<span class="n">Mode6</span> <span class="o">=</span> <span class="n">Data2D</span><span class="p">.</span><span class="n">point_data</span><span class="p">[</span><span class="sh">'</span><span class="s">Mode6</span><span class="sh">'</span><span class="p">]</span>
</code></pre></div></div> <p>Now, using simple Python plotting routines, we can visualize the first six modes on this 2D slice:</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog4_2025/First6Modes_POD.jpeg" width="80%"/> </figure> <p>In this tutorial, we explored how to apply Proper Orthogonal Decomposition (POD) to analyze 3D fluid flow data from OpenFOAM simulations. By leveraging MODULO for efficient mode extraction and Python for visualization, we were able to gain valuable insights into the flow’s dominant structures and energy distribution. We also demonstrated how to visualize these modes in both 3D using ParaView and in 2D slices for more detailed analysis. The combination of these tools provides a powerful approach for investigating complex flow phenomena, offering both clarity and computational efficiency.</p>]]></content><author><name></name></author><category term="DataAnalysis"/><category term="Modal Decomposition"/><category term="Python"/><summary type="html"><![CDATA[In fluid dynamics, understanding the intricate patterns hidden within three-dimensional flow data is crucial for advancing both research and engineering applications. Proper Orthogonal Decomposition (POD) serves as a powerful tool to extract dominant flow structures, simplifying complex dynamics into comprehensible insights. This article takes you through the step-by-step application of three-dimensional POD using OpenFOAM simulation data and Python wizardry, emphasizing visualization for enhanced interpretation. Whether you’re a CFD enthusiast or a seasoned researcher, this guide will equip you with practical skills to explore and analyze multi-dimensional fluid flows effectively.]]></summary></entry><entry><title type="html">Optimizing Outputs with OpenFOAM’s writeObjects</title><link href="https://goswami-13.github.io/goswami-13/posts/2025/01/blog-post-45/" rel="alternate" type="text/html" title="Optimizing Outputs with OpenFOAM’s writeObjects"/><published>2025-01-27T00:00:00+00:00</published><updated>2025-01-27T00:00:00+00:00</updated><id>https://goswami-13.github.io/goswami-13/posts/2025/01/blog-post-45</id><content type="html" xml:base="https://goswami-13.github.io/goswami-13/posts/2025/01/blog-post-45/"><![CDATA[<p>Efficient data handling is a cornerstone of successful computational fluid dynamics simulations, and OpenFOAM provides powerful tools to achieve this. Among them, the <code class="language-plaintext highlighter-rouge">writeObjects</code> function object stands out for its ability to specify different writing frequencies for various objects registered in the simulation database. This capability allows users to tailor output schedules for volume fields and other entities, optimizing disk usage and post-processing workflows. In this blog, we will explore how configuring and utilizing writeObjects can enhance simulation efficiency. Whether you’re optimizing a large-scale simulation or managing limited resources, this guide will help you make the most of OpenFOAM’s functionality.</p> <figure> <img src="https://goswami-13.github.io/images/2025/Blog3_2025/BlogLogo.jpeg" width="80%"/> </figure> <p>In computational fluid dynamics, managing simulation data efficiently is as critical as running the simulation itself. OpenFOAM offers a robust feature set to help users optimize their workflows. Among these features, the <code class="language-plaintext highlighter-rouge">writeObjects</code> function object provides a simple yet powerful way to control the writing frequency of various objects registered in the simulation database. Whether you’re working with scalar fields, vector fields, or surface data, this functionality enables you to reduce redundant outputs and streamline post-processing without compromising on the data you need.</p> <p>In this blog, we’ll explore how the <code class="language-plaintext highlighter-rouge">writeObjects</code> function object works, why it’s an essential tool for any OpenFOAM user, and how to configure it effectively for your simulations. By the end of this article, you’ll have a clear understanding of how to leverage <code class="language-plaintext highlighter-rouge">writeObjects</code> to balance simulation output precision with resource efficiency.</p> <p>For this tutorial, I will again use the simulation of three-dimensional flow around a square cylinder at Reynolds number of 260. You can find a reference case setup <a href="https://github.com/goswami-13/3D_SquareCylinder.git">here</a>.</p> <p>Lets Begin!!!</p> <h1 id="openfoam-object-registry">OpenFOAM Object Registry</h1> <p>Before diving into the <code class="language-plaintext highlighter-rouge">writeObjects</code> function, it’s crucial to understand the OpenFOAM object registry, as this is the source from which we will extract our fields of interest. The <strong>objectRegistry</strong> serves as a hierarchical database that OpenFOAM uses to organize case-related data. This structured database is maintained by OpenFOAM solvers at various levels:</p> <ol> <li><strong>Primary Registry:</strong> This is the Time object or the <code class="language-plaintext highlighter-rouge">runTime</code> database, which acts as the root of the objectRegistry.</li> <li><strong>Second-Tier Database:</strong> This level consists of mesh regions and global properties defined in the <code class="language-plaintext highlighter-rouge">controlDict</code>.</li> <li><strong>Lower Levels:</strong> Sub-objects are registered here, such as individual mesh regions with their respective fvSchemes, fvSolution, mesh data, and fields created in files like createFields.H.</li> </ol> <p>The objectRegistry is built around two main components:</p> <ol> <li><strong>IOobject:</strong> This class standardizes input/output operations and provides access to <code class="language-plaintext highlighter-rouge">runTime</code>, the root of the objectRegistry.</li> <li><strong>regIOobject:</strong> This class automates the registration and deregistration of objects within the objectRegistry.</li> </ol> <p>By understanding the objectRegistry, we can better grasp how writeObjects interacts with these components to selectively output data from a simulation. For instance, in a standard solver, the objectRegistry might look like this:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">*</span> runTime         <span class="c"># objectRegistry</span>
 |--&gt; controlDict <span class="c"># regIOobject (can't have sub-entries attached to it)</span>
 |--&gt; mesh1       <span class="c"># objectRegistry (a database)</span>
    |--&gt; points, owner, neighbour, cellZones ...
    |--&gt; fvSchemes, fvSolution
    |--&gt; U, p
 |--&gt; mesh2
    |--&gt; points, owner, neighbour, cellZones ...
    |--&gt; fvSchemes, fvSolution
    |--&gt; U, p
</code></pre></div></div> <p>For instance, let’s explore the objectRegistry or check the available objects in the database for a sample simulation. You can do this by running the following command in a terminal where OpenFOAM is sourced:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pimpleFoam <span class="nt">-postProcess</span> <span class="nt">-func</span> <span class="s2">"writeObjects(banana)"</span> <span class="nt">-latestTime</span>
</code></pre></div></div> <p>In this example, since <code class="language-plaintext highlighter-rouge">banana</code> is not a valid object in the OpenFOAM simulation database, the executable will output a list of available objects that you can choose from. For example, the output in my case looks like this:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>writeObjects writeObjects<span class="o">(</span>banana<span class="o">)</span> write:
<span class="nt">--</span><span class="o">&gt;</span> FOAM Warning :
    From virtual bool Foam::functionObjects::writeObjects::write<span class="o">()</span>
    <span class="k">in </span>file writeObjects/writeObjects.C at line 162
    No corresponding selection <span class="k">for</span> <span class="o">(</span>banana<span class="o">)</span>
Available objects <span class="k">in </span>database:

20
<span class="o">(</span>
MRFProperties
U
boundary
cellZones
data
faceZones
faces
fvOptions
fvSchemes
fvSolution
neighbour
nu
owner
p
phi
pointZones
points
solutionControl
transportProperties
turbulenceProperties
<span class="o">)</span>
</code></pre></div></div> <p>This approach is a straightforward way to inspect the objectRegistry and identify objects available for post-processing or output customization. The output reveals that there are 20 objects available in my simulation that can be written out. For example, velocity and pressure fields are commonly available for this purpose. Let’s use the same command as before but this time attempt to write the <code class="language-plaintext highlighter-rouge">phi</code> field:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pimpleFoam <span class="nt">-postProcess</span> <span class="nt">-func</span> <span class="s2">"writeObjects(phi)"</span> <span class="nt">-latestTime</span>
</code></pre></div></div> <p>This command should create a <code class="language-plaintext highlighter-rouge">phi</code> field in your <code class="language-plaintext highlighter-rouge">latestTime</code> folder. If the <code class="language-plaintext highlighter-rouge">phi</code> field already exists in the folder, you can delete it and run the command again to ensure it’s correctly written out. This demonstrates how <code class="language-plaintext highlighter-rouge">writeObjects</code> can be used to selectively output specific fields from the simulation database.</p> <h1 id="extracting-fields-using-writeobjects">Extracting fields using writeObjects</h1> <p>Imagine a scenario where you are running a simulation on an HPC system with limited storage. To conserve space, you might use the <code class="language-plaintext highlighter-rouge">purgeWrite</code> setting to retain only the last three time steps. However, what if you need full-domain velocity and pressure snapshots from the simulation? This is where the <code class="language-plaintext highlighter-rouge">writeObjects</code> function object becomes incredibly useful.</p> <p>The <code class="language-plaintext highlighter-rouge">writeObjects</code> function object operates similarly to the <code class="language-plaintext highlighter-rouge">writeControl</code> setting in your <code class="language-plaintext highlighter-rouge">controlDict</code>. It allows you to write out specific fields of interest at a defined frequency. Let’s see how to configure it. Add the following lines of code to the <code class="language-plaintext highlighter-rouge">&lt;case&gt;/controlDict/functions</code> section:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  fieldofinterest
	<span class="o">{</span>
	   <span class="nb">type        </span>writeObjects<span class="p">;</span>
	   libs        <span class="o">(</span><span class="s2">"libutilityFunctionObjects.so"</span><span class="o">)</span><span class="p">;</span>
	   objects     <span class="o">(</span>U p<span class="o">)</span><span class="p">;</span>
	   writeControl    timeStep<span class="p">;</span>
	   writeInterval   25<span class="p">;</span>
	   purgeWrite      0<span class="p">;</span>
	   writeFormat     ascii<span class="p">;</span>
	   writePrecision  8<span class="p">;</span>
	   writeCompression uncompressed<span class="p">;</span>
	   timeFormat      general<span class="p">;</span>
	   timePrecision   8<span class="p">;</span>
	   writeOption autoWrite<span class="p">;</span>
	<span class="o">}</span>
</code></pre></div></div> <p>This configuration saves velocity (U) and pressure (p) fields every 25 time steps, which is significantly more frequent than the full simulation write interval. This allows you to collect detailed snapshots of the fields while keeping the size of your simulation directory manageable.</p> <p>For instance, let’s compare the size of two time directories: one containing only the fields of interest and the other with the full simulation data:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">du</span> <span class="nt">-sh</span> 1996.85/ 1997.05/
<span class="c">## OUTPUT</span>
<span class="c">## 21M     1996.85/</span>
<span class="c">## 67M     1997.05/</span>
</code></pre></div></div> <p>The results clearly show that the directory containing only the fields of interest is significantly smaller, demonstrating the effectiveness of the <code class="language-plaintext highlighter-rouge">writeObjects</code> function in managing disk space without sacrificing data granularity.</p> <h1 id="extended-usage">Extended usage</h1> <p>The <code class="language-plaintext highlighter-rouge">writeObjects</code> function object can be further extended for more advanced use cases. Imagine a scenario where you want to exclude certain variables from being written to files while specifying others to be saved. This is particularly useful in multiphase simulations, where you might deal with multiple fields and want precise control over what gets written.</p> <p>To achieve this, you can define multiple <code class="language-plaintext highlighter-rouge">writeObjects</code> function objects in your <code class="language-plaintext highlighter-rouge">controlDict</code>, specifying which fields to omit and which to write. Ensure that the <code class="language-plaintext highlighter-rouge">controlDict/writeInterval</code> is set appropriately to control the overall output frequency. For example:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>functions
<span class="o">{</span>
	  writeObjects1
		<span class="o">{</span>
			<span class="nb">type        </span>writeObjects<span class="p">;</span>
			libs        <span class="o">(</span><span class="s2">"libutilityFunctionObjects.so"</span><span class="o">)</span><span class="p">;</span>
			objects     <span class="o">(</span>rho nut alphat alphaPhi0.water phi T.air T.water<span class="o">)</span><span class="p">;</span>
			writeOption noWrite<span class="p">;</span>
		<span class="o">}</span>
	  writeObjects2
		<span class="o">{</span>
			<span class="nb">type        </span>writeObjects<span class="p">;</span>
			libs        <span class="o">(</span><span class="s2">"libutilityFunctionObjects.so"</span><span class="o">)</span><span class="p">;</span>
			objects     <span class="o">(</span>U p T alpha.water<span class="o">)</span><span class="p">;</span>
			writeOption autoWrite<span class="p">;</span>
		<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>In this setup:</p> <ul> <li>The first function object, <code class="language-plaintext highlighter-rouge">writeObjects1</code>, excludes fields like <code class="language-plaintext highlighter-rouge">rho</code>, <code class="language-plaintext highlighter-rouge">nut</code>, and <code class="language-plaintext highlighter-rouge">alphat</code> using the <code class="language-plaintext highlighter-rouge">noWrite</code> option, ensuring they are not written to disk.</li> <li>The second function object, <code class="language-plaintext highlighter-rouge">writeObjects2</code>, uses the <code class="language-plaintext highlighter-rouge">autoWrite</code> option for fields such as <code class="language-plaintext highlighter-rouge">U</code>, <code class="language-plaintext highlighter-rouge">p</code>, <code class="language-plaintext highlighter-rouge">T</code>, and <code class="language-plaintext highlighter-rouge">alpha.water</code>, following the output frequency specified in <code class="language-plaintext highlighter-rouge">controlDict/writeInterval</code>.</li> </ul> <p>This flexibility allows you to optimize both storage usage and post-processing requirements by precisely managing what data is written out during your simulations.</p>]]></content><author><name></name></author><category term="OpenFOAM"/><category term="Data Extraction"/><category term="Data Management"/><summary type="html"><![CDATA[Efficient data handling is a cornerstone of successful computational fluid dynamics simulations, and OpenFOAM provides powerful tools to achieve this. Among them, the writeObjects function object stands out for its ability to specify different writing frequencies for various objects registered in the simulation database. This capability allows users to tailor output schedules for volume fields and other entities, optimizing disk usage and post-processing workflows. In this blog, we will explore how configuring and utilizing writeObjects can enhance simulation efficiency. Whether you’re optimizing a large-scale simulation or managing limited resources, this guide will help you make the most of OpenFOAM’s functionality.]]></summary></entry></feed>